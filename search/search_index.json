{
    "docs": [
        {
            "location": "/",
            "text": "Dandelion\n\n\nA quite light weight deep learning framework, on top of Theano, offering better balance between flexibility and abstraction.\n\n\nTargeted Users\n\n\nResearchers who need flexibility as well as convenience to experiment all kinds of \nnonstandard\n network structures, and also the stability of Theano.\n\n\nWhy Another DL Framework\n\n\n\n\nThe reason is more about the lack of flexibility for existing DL frameworks, such as Keras, Lasagne, Blocks, etc.\n\n\nBy \n\u201cflexibility\u201d\n, we means whether it is easy to modify or extend the framework. \n\n\nThe famous DL framework Keras is designed to be beginner-friendly oriented, at the cost of being quite hard to modify.\n\n\nCompared to Keras, another less-famous framework Lasagne provides more flexibility. It\u2019s easier to write your own layer by Lasagne for small neural network, however, for complex neural networks it still needs quite manual works because like other existing frameworks, Lasagne operates on abstracted \u2018Layer\u2019 class instead of raw tensor variables.\n\n\n\n\n\n\n\n\nFeaturing\n\n\n\n\nAiming to offer better balance between flexibility and abstraction.\n\n\nEasy to use and extend, support for any neural network structure.  \n\n\nLoose coupling, each part of the framework can be modified independently.\n\n\n\n\n\n\nMore like a handy library of deep learning modules.\n\n\nCommon modules such as CNN, LSTM, GRU, Dense, Dropout, Batch Normalization, and common optimization methods such as SGD, Adam, Adadelta, Rmsprop are ready out-of-the-box.\n\n\n\n\n\n\nPlug & play, operating directly on Theano tensors, no upper abstraction applied.\n\n\nUnlike previous frameworks like Keras, Lasagne, etc., Dandelion operates directly on tensors instead of layer abstractions, making it quite easy to plug in 3rd part defined deep learning modules (layer defined by Keras/Lasagne) or vice versa.\n\n\n\n\n\n\n\n\nProject Layout\n\n\n\n\n\n\n\n\nPython Module\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nmodule\n\n\nall neual network module definitions\n\n\n\n\n\n\nfunctional\n\n\noperations on tensor with no parameter to be learned\n\n\n\n\n\n\ninitialization\n\n\ninitialization methods for neural network modules\n\n\n\n\n\n\nactivation\n\n\ndefinition of all activation functions\n\n\n\n\n\n\nobjective\n\n\ndefinition of all loss objectives\n\n\n\n\n\n\nupdate\n\n\ndefinition of all optimizers\n\n\n\n\n\n\nutil\n\n\nutility functions\n\n\n\n\n\n\nmodel\n\n\nmodel implementations out-of-the-box\n\n\n\n\n\n\next\n\n\nextensions\n\n\n\n\n\n\n\n\nCredits\n\n\nThe design of Dandelion heavily draws on \nLasagne\n and \nPytorch\n, both my favorate DL libraries.\n\n\nSpecial Thanks\n\n\nTo \nRadomir Dopieralski\n, who transferred the \ndandelion\n project name on pypi to us. Now you can install the package by simply \npip install dandelion\n.",
            "title": "Home"
        },
        {
            "location": "/#dandelion",
            "text": "A quite light weight deep learning framework, on top of Theano, offering better balance between flexibility and abstraction.",
            "title": "Dandelion"
        },
        {
            "location": "/#targeted-users",
            "text": "Researchers who need flexibility as well as convenience to experiment all kinds of  nonstandard  network structures, and also the stability of Theano.",
            "title": "Targeted Users"
        },
        {
            "location": "/#why-another-dl-framework",
            "text": "The reason is more about the lack of flexibility for existing DL frameworks, such as Keras, Lasagne, Blocks, etc.  By  \u201cflexibility\u201d , we means whether it is easy to modify or extend the framework.   The famous DL framework Keras is designed to be beginner-friendly oriented, at the cost of being quite hard to modify.  Compared to Keras, another less-famous framework Lasagne provides more flexibility. It\u2019s easier to write your own layer by Lasagne for small neural network, however, for complex neural networks it still needs quite manual works because like other existing frameworks, Lasagne operates on abstracted \u2018Layer\u2019 class instead of raw tensor variables.",
            "title": "Why Another DL Framework"
        },
        {
            "location": "/#featuring",
            "text": "Aiming to offer better balance between flexibility and abstraction.  Easy to use and extend, support for any neural network structure.    Loose coupling, each part of the framework can be modified independently.    More like a handy library of deep learning modules.  Common modules such as CNN, LSTM, GRU, Dense, Dropout, Batch Normalization, and common optimization methods such as SGD, Adam, Adadelta, Rmsprop are ready out-of-the-box.    Plug & play, operating directly on Theano tensors, no upper abstraction applied.  Unlike previous frameworks like Keras, Lasagne, etc., Dandelion operates directly on tensors instead of layer abstractions, making it quite easy to plug in 3rd part defined deep learning modules (layer defined by Keras/Lasagne) or vice versa.",
            "title": "Featuring"
        },
        {
            "location": "/#project-layout",
            "text": "Python Module  Explanation      module  all neual network module definitions    functional  operations on tensor with no parameter to be learned    initialization  initialization methods for neural network modules    activation  definition of all activation functions    objective  definition of all loss objectives    update  definition of all optimizers    util  utility functions    model  model implementations out-of-the-box    ext  extensions",
            "title": "Project Layout"
        },
        {
            "location": "/#credits",
            "text": "The design of Dandelion heavily draws on  Lasagne  and  Pytorch , both my favorate DL libraries.",
            "title": "Credits"
        },
        {
            "location": "/#special-thanks",
            "text": "To  Radomir Dopieralski , who transferred the  dandelion  project name on pypi to us. Now you can install the package by simply  pip install dandelion .",
            "title": "Special Thanks"
        },
        {
            "location": "/tutorial I - Sentence Topic Classification/",
            "text": "Tutorial I: Sentence topic classification\n\n\nThe best way to understand how Dandelion works is through practical examples. \n\n\nIn the first part of this tutorial, you\u2019ll be guided through model definition and train/test/predict function compiling with a practical sentence classification task.\n\n\nSentence Classification Task\n\n\n\n\nObjective: classify each sentence into different topic categories.\n\n\nVariant: single-tag classification vs multi-tag classification\n\n\n\n\nThe sentence classification task is to using neural network model to determine the topic of each sentence, i.e., what each sentence is talking about. For example: time, location, cause, action and result.  \n\n\nTo fulfill the task, we\u2019ll build a model basically based on RNN, LSTM specifically. \n\n\nModel Definition - Modules\n\n\nFor the full model definition, check the following code snippet:\n\n\n    import theano\n    import theano.tensor as tensor\n    from dandelion.module import *\n    from dandelion.update import *\n    from dandelion.functional import *\n    from dandelion.util import gpickle\n\n    class model(Module):\n        def __init__(self, batchsize=None, input_length=None, Nclass=6, noise=(0.5, 0.2, 0.7, 0.7, 0.7)):\n            super().__init__()\n            self.batchsize = batchsize\n            self.input_length = input_length\n            self.Nclass = Nclass\n            self.noise = noise\n\n            self.dropout0 = Dropout(name='dropout0')\n            self.dropout1 = Dropout(name='dropout1')\n            self.dropout2 = Dropout(name='dropout2')\n            self.dropout3 = Dropout(name='dropout3')\n            self.dropout4 = Dropout(name='dropout4') \n            W = gpickle.load('word_embedding(6336, 256).gpkl')\n            self.embedding = Embedding(num_embeddings=6336, embedding_dim=256, W=W, name='Embedding')\n            self.lstm0 = LSTM(input_dims=256, hidden_dim=100, name='lstm0')\n            self.lstm1 = LSTM(input_dims=256, hidden_dim=100, name='lstm1')\n            self.lstm2 = LSTM(input_dims=200, hidden_dim=100, name='lstm2')\n            self.lstm3 = LSTM(input_dims=200, hidden_dim=100, name='lstm3')\n            self.lstm4 = LSTM(input_dims=200, hidden_dim=100, name='lstm4')\n            self.lstm5 = LSTM(input_dims=200, hidden_dim=100, name='lstm5')\n            self.dense = Dense(input_dims=200, output_dim=Nclass, name='dense')\n\n\n\n\n\nAll the neural network modules are defined in \ndandelion.module\n in Python. For the sentence classification task, the following four NN modules will be used: \nDropout\n, \nEmbedding\n, \nLSTM\n and \nDense\n.  \n\n\nTo define our model, we\u2019ll need to subclass the \nModule\n class from \ndandelion.module\n. The \nModule\n class is the base class for all our NN modules. There\u2019s no complex abstraction here, all \nModule\n class done is to define some convenient interfaces for model parameter manipulation and no more. The \nModule\n class is quite similar with Pytorch\u2019s \nnn.Module\n class.  \n\n\nNow we define all the network modules as our model\u2019s attributes, such as\n\n\n    self.dropout0 = Dropout(name='dropout0')\n\n\n\n\nYou can drop the name here, it\u2019s optional. \nHowever for possible parameter manipulation convenience later, we\u2019d suggest giving a unique name for each network module here.\n (After version 0.14.0, you don't need to set the module name manually any more, they will be auto-named by the sub-module keys)\n\n\nNote that all these definitions are done in the \nmodel\n\u2019s \n__init__()\n part. Now we defined all the NN modules to be used in our model, but their relations, i.e., the network structure hasn\u2019t been done. This part will be defined in model\u2019s \nforward()\n and \npredict()\n functions later.\n\n\nIf you\u2019re familiar with Lasagne or Keras, you\u2019d notice that for \nLSTM\n module, Dandelion requires both the input dimension via \ninput_dims\n and output dimension via \nhidden_dim\n meanwhile Lasagne or Keras would only require the output dimension, leaving the input dimension determined automatically by the framework. This is the cost you\u2019d pay for greater flexibility by using Dandelion. \n\n\nModel Definition - Structures\n\n\nNow we\u2019ll go through the network structure part. Usually a model needs to be trained first then it can be used in inference, so the network structure would involve these two different processes, i.e., training and inference.\n\n\nWe define the network structure for training in \nModel\n\u2019s \nforward()\n function, as showed below.\n\n\n    def forward(self, x):\n        self.work_mode = 'train'\n        x = self.dropout0.forward(x, p=self.noise[0], rescale=False)\n        x = self.embedding.forward(x)         # (B, T, D)\n\n        x = self.dropout1.forward(x, p=self.noise[1], rescale=True)\n        x = x.dimshuffle((1, 0, 2))           # (B, T, D) -> (T, B, D)\n        x_f = self.lstm0.forward(x, None, None, None)\n        x_b = self.lstm1.forward(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = pool_1d(x, ws=2, ignore_border=True, mode='average_exc_pad', axis=0)\n\n        x = self.dropout2.forward(x, p=self.noise[2], rescale=True)\n        x_f = self.lstm2.forward(x, None, None, None)\n        x_b = self.lstm3.forward(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = self.dropout3.forward(x, p=self.noise[3], rescale=True)\n        x_f = self.lstm4.forward(x, None, None, None, only_return_final=True)\n        x_b = self.lstm5.forward(x, None, None, None, only_return_final=True, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=1)\n\n        x = self.dropout4.forward(x, p=self.noise[4], rescale=True)\n        y = sigmoid(self.dense.forward(x))\n        return y\n\n\n\n\nWithin the \nforward()\n function, we first set the work mode to \ntrain\n. This is an optional step, which will be explained later. Then the input text sequence is fed through a \nDropout\n and \nEmbedding\n module to convert integer indices into character embedding vectors.  After that are two \nLSTM\n modules with forward and backward scanning directions, resulting in a bidirectional LSTM. Output of this bi-LSTM is then subsampled along the time dimension, and then fed into another bi-LSTM. Note that for the latter bi-LSTM, we only need the last time frame as output. Finally a \nDense\n module followed by a \nsigmoid\n activation gives the sentence classification result.\n\n\nThe network structure can be plotted as\n\n\n\n\nHere the five \nDropout\n modules are plotted with green color, means they only exist during training process.\n\n\n    def predict(self, x):\n        self.work_mode = 'inference'\n        x = self.embedding.predict(x)\n\n        x = x.dimshuffle((1, 0, 2))  # (B, T, D) -> (T, B, D)\n        x_f = self.lstm0.predict(x, None, None, None)\n        x_b = self.lstm1.predict(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = pool_1d(x, ws=2, ignore_border=True, mode='average_exc_pad', axis=0)\n\n        x_f = self.lstm2.predict(x, None, None, None)\n        x_b = self.lstm3.predict(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x_f = self.lstm4.predict(x, None, None, None, only_return_final=True)\n        x_b = self.lstm5.predict(x, None, None, None, only_return_final=True, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=1)\n\n        y = sigmoid(self.dense.predict(x))\n        return y\n\n\n\n\nNow we define the network structure for inference in \nmodel\n\u2019s \npredict()\n function, as showed above.\n\n\nDuring inference process, the \nmodel\n\u2019s network structure is simpler than in training. Note that there\u2019s no \nDropout\n modules here. The rest part of the \npredict()\n function is quite the same with \nforward()\n function, except that now all the modules\u2019 \npredict()\n interface are called instead of the \nforward()\n interface as in \nmodel\n\u2019s \nforward()\n function.\n\n\nUnified Calling Interface\n\n\nFor users familiar with Keras or Lasagne, you might be confused that we define separate functions for both training and inference. In Keras/Lasagne, the common way is to define the model\u2019s structure and use a flag parameter to tell the model to work in training mode or in inference mode.\n\n\nThe reason we do this is because it allows us to use different network structures for different purpose, i.e., the model\u2019s network structure for training can be quite different from the structure for inference.\n\n\nHowever the cost of this flexibility is that we\u2019d have to define the network structure twice even though in most scenarios the model\u2019s network structure is the same for both training and inference.\n\n\nFortunately we\u2019ve considered this and provide a \nunified calling interface\n in Dandelion. For the network structures defined before, they can be re-written by the unified calling interface as follows\n\n\n    def call(self, x, work_mode='train'):\n        self.work_mode = work_mode\n        x = self.dropout0(x, p=self.noise[0], rescale=False)\n        x = self.embedding(x)         # (B, T, D)\n\n        x = self.dropout1(x, p=self.noise[1], rescale=True)\n        x = x.dimshuffle((1, 0, 2))           # (B, T, D) -> (T, B, D)\n        x_f = self.lstm0(x, None, None, None)\n        x_b = self.lstm1(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = pool_1d(x, ws=2, ignore_border=True, mode='average_exc_pad', axis=0)\n\n        x = self.dropout2(x, p=self.noise[2], rescale=True)\n        x_f = self.lstm2(x, None, None, None)\n        x_b = self.lstm3(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = self.dropout3(x, p=self.noise[3], rescale=True)\n        x_f = self.lstm4(x, None, None, None, only_return_final=True)\n        x_b = self.lstm5(x, None, None, None, only_return_final=True, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=1)\n\n        x = self.dropout4(x, p=self.noise[4], rescale=True)\n        y = sigmoid(self.dense(x))\n        return y\n\n\n\n\nAs we can see from the code above, now we do not call the sub-module\u2019s \nforward()\n or \npredict()\n interface anymore. By setting the \nwork_mode\n parameter, Dandelion will automatically call the sub-module\u2019s \nforward()\n or \npredict()\n interface accordingly. Now we only need define the network structure for once, and use it for both training and inference.\n\n\nModel Compiling\n\n\nTheano requires compiling the computation graph before using it. The model compiling is actually more relevant to Theano than to Dandelion. \n\n\n    print('  compiling train func')\n    X            = tensor.imatrix('X')  \n    Y            = tensor.fmatrix('Y')       \n    output_score = model.forward(X)          \n    B            = Y.shape[0]\n    B            = tensor.cast(B, 'float32')\n    loss         = tensor.sqrt(tensor.sum((output_score - Y)**2)) / B * 100                                        \n\n    Y_out_positive = tensor.zeros_like(output_score)\n    Y_out_positive = tensor.switch(output_score>0.5, Y, Y_out_positive)\n    acc_positive   = tensor.sum(Y_out_positive) / tensor.sum(Y)\n\n    Y_out_negative = tensor.zeros_like(output_score)\n    Y_out_negative = tensor.switch(output_score<=0.5, 1.0 - Y, Y_out_negative)\n    acc_negative   = tensor.sum(Y_out_negative) / tensor.sum(1.0- Y)\n\n    params       = model.collect_params()\n    updates      = adadelta(loss, params)\n    updates.update(model.collect_self_updates())\n    train_fn = theano.function([X, Y], [loss, acc_positive, acc_negative], updates=updates, no_default_updates=False)\n\n\n\n\n\n\n\n\nModel Calling\n\nHere we call the model defined before by \nmodel.forward()\n. Of course you can also call the model by the unified calling interface as \nmodel.call(\u2026, work_mode=\u2018train\u2019)\n\n\n\n\n\n\nParameters Collecting\n\nParameters to be trained by optimizer can be collected from the model by calling \nmodel.collect_params()\n, simply like that.\n\n\n\n\n\n\nUpdates Collecting\n\nIn Dandelion, there\u2019re two kinds of parameters: parameters to be updated by optimizer and parameters to be updated by other methods. The updates expression of the latter part of parameters can be collected by calling \nmodel.collect_self_updates()\n. Returned is a \ndict\n describing updates for each parameter accordingly.\nAfter these 3 steps, now we can compile the training function by Theano simply by\n\n\n\n\n\n\n    train_fn = theano.function([X, Y], [loss, acc_positive, acc_negative], updates=updates, no_default_updates=False)",
            "title": "I - Sentence Topic Classification"
        },
        {
            "location": "/tutorial I - Sentence Topic Classification/#tutorial-i-sentence-topic-classification",
            "text": "The best way to understand how Dandelion works is through practical examples.   In the first part of this tutorial, you\u2019ll be guided through model definition and train/test/predict function compiling with a practical sentence classification task.",
            "title": "Tutorial I: Sentence topic classification"
        },
        {
            "location": "/tutorial I - Sentence Topic Classification/#sentence-classification-task",
            "text": "Objective: classify each sentence into different topic categories.  Variant: single-tag classification vs multi-tag classification   The sentence classification task is to using neural network model to determine the topic of each sentence, i.e., what each sentence is talking about. For example: time, location, cause, action and result.    To fulfill the task, we\u2019ll build a model basically based on RNN, LSTM specifically.",
            "title": "Sentence Classification Task"
        },
        {
            "location": "/tutorial I - Sentence Topic Classification/#model-definition-modules",
            "text": "For the full model definition, check the following code snippet:      import theano\n    import theano.tensor as tensor\n    from dandelion.module import *\n    from dandelion.update import *\n    from dandelion.functional import *\n    from dandelion.util import gpickle\n\n    class model(Module):\n        def __init__(self, batchsize=None, input_length=None, Nclass=6, noise=(0.5, 0.2, 0.7, 0.7, 0.7)):\n            super().__init__()\n            self.batchsize = batchsize\n            self.input_length = input_length\n            self.Nclass = Nclass\n            self.noise = noise\n\n            self.dropout0 = Dropout(name='dropout0')\n            self.dropout1 = Dropout(name='dropout1')\n            self.dropout2 = Dropout(name='dropout2')\n            self.dropout3 = Dropout(name='dropout3')\n            self.dropout4 = Dropout(name='dropout4') \n            W = gpickle.load('word_embedding(6336, 256).gpkl')\n            self.embedding = Embedding(num_embeddings=6336, embedding_dim=256, W=W, name='Embedding')\n            self.lstm0 = LSTM(input_dims=256, hidden_dim=100, name='lstm0')\n            self.lstm1 = LSTM(input_dims=256, hidden_dim=100, name='lstm1')\n            self.lstm2 = LSTM(input_dims=200, hidden_dim=100, name='lstm2')\n            self.lstm3 = LSTM(input_dims=200, hidden_dim=100, name='lstm3')\n            self.lstm4 = LSTM(input_dims=200, hidden_dim=100, name='lstm4')\n            self.lstm5 = LSTM(input_dims=200, hidden_dim=100, name='lstm5')\n            self.dense = Dense(input_dims=200, output_dim=Nclass, name='dense')  All the neural network modules are defined in  dandelion.module  in Python. For the sentence classification task, the following four NN modules will be used:  Dropout ,  Embedding ,  LSTM  and  Dense .    To define our model, we\u2019ll need to subclass the  Module  class from  dandelion.module . The  Module  class is the base class for all our NN modules. There\u2019s no complex abstraction here, all  Module  class done is to define some convenient interfaces for model parameter manipulation and no more. The  Module  class is quite similar with Pytorch\u2019s  nn.Module  class.    Now we define all the network modules as our model\u2019s attributes, such as      self.dropout0 = Dropout(name='dropout0')  You can drop the name here, it\u2019s optional.  However for possible parameter manipulation convenience later, we\u2019d suggest giving a unique name for each network module here.  (After version 0.14.0, you don't need to set the module name manually any more, they will be auto-named by the sub-module keys)  Note that all these definitions are done in the  model \u2019s  __init__()  part. Now we defined all the NN modules to be used in our model, but their relations, i.e., the network structure hasn\u2019t been done. This part will be defined in model\u2019s  forward()  and  predict()  functions later.  If you\u2019re familiar with Lasagne or Keras, you\u2019d notice that for  LSTM  module, Dandelion requires both the input dimension via  input_dims  and output dimension via  hidden_dim  meanwhile Lasagne or Keras would only require the output dimension, leaving the input dimension determined automatically by the framework. This is the cost you\u2019d pay for greater flexibility by using Dandelion.",
            "title": "Model Definition - Modules"
        },
        {
            "location": "/tutorial I - Sentence Topic Classification/#model-definition-structures",
            "text": "Now we\u2019ll go through the network structure part. Usually a model needs to be trained first then it can be used in inference, so the network structure would involve these two different processes, i.e., training and inference.  We define the network structure for training in  Model \u2019s  forward()  function, as showed below.      def forward(self, x):\n        self.work_mode = 'train'\n        x = self.dropout0.forward(x, p=self.noise[0], rescale=False)\n        x = self.embedding.forward(x)         # (B, T, D)\n\n        x = self.dropout1.forward(x, p=self.noise[1], rescale=True)\n        x = x.dimshuffle((1, 0, 2))           # (B, T, D) -> (T, B, D)\n        x_f = self.lstm0.forward(x, None, None, None)\n        x_b = self.lstm1.forward(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = pool_1d(x, ws=2, ignore_border=True, mode='average_exc_pad', axis=0)\n\n        x = self.dropout2.forward(x, p=self.noise[2], rescale=True)\n        x_f = self.lstm2.forward(x, None, None, None)\n        x_b = self.lstm3.forward(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = self.dropout3.forward(x, p=self.noise[3], rescale=True)\n        x_f = self.lstm4.forward(x, None, None, None, only_return_final=True)\n        x_b = self.lstm5.forward(x, None, None, None, only_return_final=True, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=1)\n\n        x = self.dropout4.forward(x, p=self.noise[4], rescale=True)\n        y = sigmoid(self.dense.forward(x))\n        return y  Within the  forward()  function, we first set the work mode to  train . This is an optional step, which will be explained later. Then the input text sequence is fed through a  Dropout  and  Embedding  module to convert integer indices into character embedding vectors.  After that are two  LSTM  modules with forward and backward scanning directions, resulting in a bidirectional LSTM. Output of this bi-LSTM is then subsampled along the time dimension, and then fed into another bi-LSTM. Note that for the latter bi-LSTM, we only need the last time frame as output. Finally a  Dense  module followed by a  sigmoid  activation gives the sentence classification result.  The network structure can be plotted as   Here the five  Dropout  modules are plotted with green color, means they only exist during training process.      def predict(self, x):\n        self.work_mode = 'inference'\n        x = self.embedding.predict(x)\n\n        x = x.dimshuffle((1, 0, 2))  # (B, T, D) -> (T, B, D)\n        x_f = self.lstm0.predict(x, None, None, None)\n        x_b = self.lstm1.predict(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = pool_1d(x, ws=2, ignore_border=True, mode='average_exc_pad', axis=0)\n\n        x_f = self.lstm2.predict(x, None, None, None)\n        x_b = self.lstm3.predict(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x_f = self.lstm4.predict(x, None, None, None, only_return_final=True)\n        x_b = self.lstm5.predict(x, None, None, None, only_return_final=True, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=1)\n\n        y = sigmoid(self.dense.predict(x))\n        return y  Now we define the network structure for inference in  model \u2019s  predict()  function, as showed above.  During inference process, the  model \u2019s network structure is simpler than in training. Note that there\u2019s no  Dropout  modules here. The rest part of the  predict()  function is quite the same with  forward()  function, except that now all the modules\u2019  predict()  interface are called instead of the  forward()  interface as in  model \u2019s  forward()  function.",
            "title": "Model Definition - Structures"
        },
        {
            "location": "/tutorial I - Sentence Topic Classification/#unified-calling-interface",
            "text": "For users familiar with Keras or Lasagne, you might be confused that we define separate functions for both training and inference. In Keras/Lasagne, the common way is to define the model\u2019s structure and use a flag parameter to tell the model to work in training mode or in inference mode.  The reason we do this is because it allows us to use different network structures for different purpose, i.e., the model\u2019s network structure for training can be quite different from the structure for inference.  However the cost of this flexibility is that we\u2019d have to define the network structure twice even though in most scenarios the model\u2019s network structure is the same for both training and inference.  Fortunately we\u2019ve considered this and provide a  unified calling interface  in Dandelion. For the network structures defined before, they can be re-written by the unified calling interface as follows      def call(self, x, work_mode='train'):\n        self.work_mode = work_mode\n        x = self.dropout0(x, p=self.noise[0], rescale=False)\n        x = self.embedding(x)         # (B, T, D)\n\n        x = self.dropout1(x, p=self.noise[1], rescale=True)\n        x = x.dimshuffle((1, 0, 2))           # (B, T, D) -> (T, B, D)\n        x_f = self.lstm0(x, None, None, None)\n        x_b = self.lstm1(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = pool_1d(x, ws=2, ignore_border=True, mode='average_exc_pad', axis=0)\n\n        x = self.dropout2(x, p=self.noise[2], rescale=True)\n        x_f = self.lstm2(x, None, None, None)\n        x_b = self.lstm3(x, None, None, None, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=2)\n\n        x = self.dropout3(x, p=self.noise[3], rescale=True)\n        x_f = self.lstm4(x, None, None, None, only_return_final=True)\n        x_b = self.lstm5(x, None, None, None, only_return_final=True, backward=True)\n        x = tensor.concatenate([x_f, x_b], axis=1)\n\n        x = self.dropout4(x, p=self.noise[4], rescale=True)\n        y = sigmoid(self.dense(x))\n        return y  As we can see from the code above, now we do not call the sub-module\u2019s  forward()  or  predict()  interface anymore. By setting the  work_mode  parameter, Dandelion will automatically call the sub-module\u2019s  forward()  or  predict()  interface accordingly. Now we only need define the network structure for once, and use it for both training and inference.",
            "title": "Unified Calling Interface"
        },
        {
            "location": "/tutorial I - Sentence Topic Classification/#model-compiling",
            "text": "Theano requires compiling the computation graph before using it. The model compiling is actually more relevant to Theano than to Dandelion.       print('  compiling train func')\n    X            = tensor.imatrix('X')  \n    Y            = tensor.fmatrix('Y')       \n    output_score = model.forward(X)          \n    B            = Y.shape[0]\n    B            = tensor.cast(B, 'float32')\n    loss         = tensor.sqrt(tensor.sum((output_score - Y)**2)) / B * 100                                        \n\n    Y_out_positive = tensor.zeros_like(output_score)\n    Y_out_positive = tensor.switch(output_score>0.5, Y, Y_out_positive)\n    acc_positive   = tensor.sum(Y_out_positive) / tensor.sum(Y)\n\n    Y_out_negative = tensor.zeros_like(output_score)\n    Y_out_negative = tensor.switch(output_score<=0.5, 1.0 - Y, Y_out_negative)\n    acc_negative   = tensor.sum(Y_out_negative) / tensor.sum(1.0- Y)\n\n    params       = model.collect_params()\n    updates      = adadelta(loss, params)\n    updates.update(model.collect_self_updates())\n    train_fn = theano.function([X, Y], [loss, acc_positive, acc_negative], updates=updates, no_default_updates=False)    Model Calling \nHere we call the model defined before by  model.forward() . Of course you can also call the model by the unified calling interface as  model.call(\u2026, work_mode=\u2018train\u2019)    Parameters Collecting \nParameters to be trained by optimizer can be collected from the model by calling  model.collect_params() , simply like that.    Updates Collecting \nIn Dandelion, there\u2019re two kinds of parameters: parameters to be updated by optimizer and parameters to be updated by other methods. The updates expression of the latter part of parameters can be collected by calling  model.collect_self_updates() . Returned is a  dict  describing updates for each parameter accordingly.\nAfter these 3 steps, now we can compile the training function by Theano simply by        train_fn = theano.function([X, Y], [loss, acc_positive, acc_negative], updates=updates, no_default_updates=False)",
            "title": "Model Compiling"
        },
        {
            "location": "/tutorial II - Write Your Own Module/",
            "text": "Tutorial II: Write Your Own Module\n\n\nIn this tutorial, you\u2019ll learn how to write your own neural network module with the help of Dandelion. Here we\u2019ll design a module which gives the class centers for classification output. It\u2019s a simple case for Dandelion yet not so intuitive for Lasagne or Keras users.\n\n\nIn image classification tasks, such as face recognition, document image classification, Imagenet contests, etc., we usually consider only the \u201cpositive\u201d samples, i.e., we assume that given any input sample, it would be associated with at least one out of all the known class labels. However, in actual applications, we often also want the trained neural network model to be able to tell whether an input sample is an \u201coutsider\u201d or not.\n\n\nTo accomplish this task, we can add an extra \u201cnegative\u201d class to the final layer of the network, and then train this augmented network by feeding it with all kinds of \u201cnegative\u201d samples you can collect. It\u2019s pure data-driven, so the bottleneck is how many \u201cnegative\u201d samples can be collected. \n\n\nAnother way is algorithm-driven: we design a new network module to explore the intrinsic properties of the data, and use these \u201cproperties\u201d to reject or accept an sample as \u201cpositive\u201d. By this way we do not need to collect negative samples, and the model is more general and the most important: explainable.\n\n\nThe data intrinsic property to explore here is the class center for each positive class. The intuition is that if we can get the center of each class, then we can use the sample-center distance to reject or accept an sample as \u201cpositive\u201d. \n\n\nNow assume that the last layer of the neural network is a \nDense\n module followed by a \nsoftmax\n activation which produces \nN\n class decisions. We\u2019ll refer the input of this \nDense\n module as feature of the input sample (extracted by the former part of the whole neural network). For plain network trained with only positive samples, the feature distribution can be typically visualized as\n\n\n\n\n\n\nA Discriminative Deep Feature Learning Approach for Face Recognitions\n. Yandong Wen, Kaipeng Zhang, Zhifeng Li and Yu Qiao. European Conference on Computer Vision (ECCV) 2016\n\n\n\n\nCenter Loss\n\n\nApparently the feature extracted by the plain model is not well centered, in other words, the feature distribution is not well-formed.\n\n\nIdeally, to reject or accept one sample as a certain class, we can set a probability threshold so that any sample whose feature satisfies\n\n\ud835\udc5d(\ud835\udc53_\ud835\udc57\u2502\ud835\udc36_\ud835\udc56)<\ud835\udc47_\ud835\udc56\n\ud835\udc5d(\ud835\udc53_\ud835\udc57\u2502\ud835\udc36_\ud835\udc56)<\ud835\udc47_\ud835\udc56\n will be rejected as an \u201coutsider\u201d for this class with certainty \n1\u2212\ud835\udc47_\ud835\udc56\n1\u2212\ud835\udc47_\ud835\udc56\n\n\nBut before we can do this, the distribution \n\ud835\udc5d(\ud835\udc53\u2502\ud835\udc36_\ud835\udc56)\n\ud835\udc5d(\ud835\udc53\u2502\ud835\udc36_\ud835\udc56)\n must be known. To get this conditional distribution, we can either traverse all the train samples and use any probability estimation / modelling method to approximate the true distribution, or we can resort to the DL method by directly requiring the neural network to produce features satisfying predefined distributions.\n\n\nThe reason we can do this is because a neural network can be trained to emulate any nonlinear functions, and we can always transform a compact distribution into Gaussian by a certain function. \n\n\nTo restrain the neural network to extract Gaussian distributed features, we assume each class has a mean feature vector (i.e., center) \n\ud835\udc53_{\ud835\udf07_\ud835\udc56}\n\ud835\udc53_{\ud835\udf07_\ud835\udc56}\n and require the model to minimize the distance between extracted feature and its corresponding center vector, i.e., \n\n\nmin\u2061\u2016\ud835\udc53_\ud835\udc57\u2212\ud835\udc53_{\ud835\udf07_\ud835\udc56} \u2016^2\nmin\u2061\u2016\ud835\udc53_\ud835\udc57\u2212\ud835\udc53_{\ud835\udf07_\ud835\udc56} \u2016^2\n  \ud835\udc56\ud835\udc53 \ud835\udc60\ud835\udc4e\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc52 \nj\nj\n \ud835\udc4f\ud835\udc52\ud835\udc59\ud835\udc5c\ud835\udc5b\ud835\udc54\ud835\udc60 \ud835\udc61\ud835\udc5c \ud835\udc50\ud835\udc59\ud835\udc4e\ud835\udc60\ud835\udc60 \n\ud835\udc56\n\ud835\udc56\n\n\nWe refer this objective as \u201ccenter loss\u201d, the details can be found in Ref. [A Discriminative Deep Feature Learning Approach for Face Recognition. Yandong Wen, Kaipeng Zhang, Zhifeng Li and Yu Qiao. European Conference on Computer Vision (ECCV) 2016]. The model is trained now with both the categorical cross entropy loss and the center loss as \n\n\nmin\nmin\n\u2061 \n\ud835\udc36\ud835\udc4e\ud835\udc61\ud835\udc52\ud835\udc54\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc50\ud835\udc4e\ud835\udc59\ud835\udc36\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60\ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc5c\ud835\udc5d\ud835\udc66+\ud835\udf06\u2217\ud835\udc36\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc52\ud835\udc5f\ud835\udc3f\ud835\udc5c\ud835\udc60\ud835\udc60\n\ud835\udc36\ud835\udc4e\ud835\udc61\ud835\udc52\ud835\udc54\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc50\ud835\udc4e\ud835\udc59\ud835\udc36\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60\ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc5c\ud835\udc5d\ud835\udc66+\ud835\udf06\u2217\ud835\udc36\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc52\ud835\udc5f\ud835\udc3f\ud835\udc5c\ud835\udc60\ud835\udc60\n  \n\n\n\n\nCenter\n Module\n\n\nNow we\u2019ll go through the code part to illustrate how the center loss can be actually computed. To compute the center loss, we need first to get the center estimation of each class. This is done through a new module referred as \nCenter\n. Check the code snippet following.\n\n\nclass Center(Module):\n    \"\"\"\n    Compute the class centers during training\n    Ref. to \"Discriminative feature learning approach for deep face recognition (2016)\"\n    \"\"\"\n    def __init__(self, feature_dim, center_num, alpha=0.9, center=init.GlorotUniform(), name=None):\n        \"\"\"\n        :param alpha: moving averaging coefficient\n        :param center: initial value of center\n        \"\"\"\n        super().__init__(name=name)\n        self.center = self.register_self_updating_variable(center, shape=[center_num, feature_dim], name=\"center\")\n        self.alpha = alpha\n\n    def forward(self, features, labels):\n        \"\"\"\n        :param features: (B, D)\n        :param labels: (B,)\n        :return: categorical centers\n        \"\"\"\n        center_batch = self.center[labels, :]\n        diff = (self.alpha - 1.0) * (center_batch - features)\n        center_updated = tensor.inc_subtensor(self.center[labels, :], diff)\n        self.center.default_update = center_updated\n        return self.center\n\n    def predict(self):\n        return self.center\n\n\n\n\n\nFirst, all our NN modules should subclass the root \nModule\n class, then we can use class methods and attributes to manipulate network parameters conveniently.\n\n\nSecond, define the module initialization in \n.__init__()\n part. Here we do two things: we register a \ncenter\n tensor as network parameter and initialize it with a Glorot uniform random numpy array. The \ncenter\n tensor is of shape \n(center_num, feature_dim)\n, in which \ncenter_num\n should be equal to class number, and \nfeature_dim\n is the dimension of extracted features by the network.\n\n\nIn Dandelion, the network parameters are divided into two categories:  \n\n\n\n\n1) parameter to be updated by optimizer,  \n\n\n2) parameter to updated by user defined expression.\n\n\n\n\nThe former parameters should be registered with class method \n.register_param()\n, and the latter parameters should be registered with class method \n. register_self_updating_variable()\n.\n\n\nNow we registered \ncenter\n tensor as self updating variable, its updating expression is given in \n.forward()\n function as \nself.center.update = center_updated\n. In Dandelion we use a specially named attribute \n. update\n to tell the framework that this parameter has an updating expression defined and the updating expression will be collected during Theano function compiling phase.\n\n\nThe \n.forward()\n function will be used for training, and \n.predict()\n function will be used for inference. \n\n\nBasically, during training, the \n.forward()\n function computes moving averaging estimation of class centers; and during inference, we just use the stored center values as final estimated class centers. This is pretty much alike how \nBatchNorm\n\u2019s mean and std are estimated and used.\n\n\nSummary\n\n\nTo summary, to write your own module, you only need to do the following three steps:\n\n\n\n\n1) subclass \nModule\n class\n\n\n2) register your module\u2019s parameters by \n.register_param()\n or \n. register_self_updating_variable()\n and initialize them\n\n\n3) define the \n.forward()\n function for training and \n.predict()\n function for inference\n\n\n\n\nand that\u2019s it!",
            "title": "II - Write Your Own Module"
        },
        {
            "location": "/tutorial II - Write Your Own Module/#tutorial-ii-write-your-own-module",
            "text": "In this tutorial, you\u2019ll learn how to write your own neural network module with the help of Dandelion. Here we\u2019ll design a module which gives the class centers for classification output. It\u2019s a simple case for Dandelion yet not so intuitive for Lasagne or Keras users.  In image classification tasks, such as face recognition, document image classification, Imagenet contests, etc., we usually consider only the \u201cpositive\u201d samples, i.e., we assume that given any input sample, it would be associated with at least one out of all the known class labels. However, in actual applications, we often also want the trained neural network model to be able to tell whether an input sample is an \u201coutsider\u201d or not.  To accomplish this task, we can add an extra \u201cnegative\u201d class to the final layer of the network, and then train this augmented network by feeding it with all kinds of \u201cnegative\u201d samples you can collect. It\u2019s pure data-driven, so the bottleneck is how many \u201cnegative\u201d samples can be collected.   Another way is algorithm-driven: we design a new network module to explore the intrinsic properties of the data, and use these \u201cproperties\u201d to reject or accept an sample as \u201cpositive\u201d. By this way we do not need to collect negative samples, and the model is more general and the most important: explainable.  The data intrinsic property to explore here is the class center for each positive class. The intuition is that if we can get the center of each class, then we can use the sample-center distance to reject or accept an sample as \u201cpositive\u201d.   Now assume that the last layer of the neural network is a  Dense  module followed by a  softmax  activation which produces  N  class decisions. We\u2019ll refer the input of this  Dense  module as feature of the input sample (extracted by the former part of the whole neural network). For plain network trained with only positive samples, the feature distribution can be typically visualized as    A Discriminative Deep Feature Learning Approach for Face Recognitions . Yandong Wen, Kaipeng Zhang, Zhifeng Li and Yu Qiao. European Conference on Computer Vision (ECCV) 2016",
            "title": "Tutorial II: Write Your Own Module"
        },
        {
            "location": "/tutorial II - Write Your Own Module/#center-loss",
            "text": "Apparently the feature extracted by the plain model is not well centered, in other words, the feature distribution is not well-formed.  Ideally, to reject or accept one sample as a certain class, we can set a probability threshold so that any sample whose feature satisfies \ud835\udc5d(\ud835\udc53_\ud835\udc57\u2502\ud835\udc36_\ud835\udc56)<\ud835\udc47_\ud835\udc56 \ud835\udc5d(\ud835\udc53_\ud835\udc57\u2502\ud835\udc36_\ud835\udc56)<\ud835\udc47_\ud835\udc56  will be rejected as an \u201coutsider\u201d for this class with certainty  1\u2212\ud835\udc47_\ud835\udc56 1\u2212\ud835\udc47_\ud835\udc56  But before we can do this, the distribution  \ud835\udc5d(\ud835\udc53\u2502\ud835\udc36_\ud835\udc56) \ud835\udc5d(\ud835\udc53\u2502\ud835\udc36_\ud835\udc56)  must be known. To get this conditional distribution, we can either traverse all the train samples and use any probability estimation / modelling method to approximate the true distribution, or we can resort to the DL method by directly requiring the neural network to produce features satisfying predefined distributions.  The reason we can do this is because a neural network can be trained to emulate any nonlinear functions, and we can always transform a compact distribution into Gaussian by a certain function.   To restrain the neural network to extract Gaussian distributed features, we assume each class has a mean feature vector (i.e., center)  \ud835\udc53_{\ud835\udf07_\ud835\udc56} \ud835\udc53_{\ud835\udf07_\ud835\udc56}  and require the model to minimize the distance between extracted feature and its corresponding center vector, i.e.,   min\u2061\u2016\ud835\udc53_\ud835\udc57\u2212\ud835\udc53_{\ud835\udf07_\ud835\udc56} \u2016^2 min\u2061\u2016\ud835\udc53_\ud835\udc57\u2212\ud835\udc53_{\ud835\udf07_\ud835\udc56} \u2016^2   \ud835\udc56\ud835\udc53 \ud835\udc60\ud835\udc4e\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc52  j j  \ud835\udc4f\ud835\udc52\ud835\udc59\ud835\udc5c\ud835\udc5b\ud835\udc54\ud835\udc60 \ud835\udc61\ud835\udc5c \ud835\udc50\ud835\udc59\ud835\udc4e\ud835\udc60\ud835\udc60  \ud835\udc56 \ud835\udc56  We refer this objective as \u201ccenter loss\u201d, the details can be found in Ref. [A Discriminative Deep Feature Learning Approach for Face Recognition. Yandong Wen, Kaipeng Zhang, Zhifeng Li and Yu Qiao. European Conference on Computer Vision (ECCV) 2016]. The model is trained now with both the categorical cross entropy loss and the center loss as   min min \u2061  \ud835\udc36\ud835\udc4e\ud835\udc61\ud835\udc52\ud835\udc54\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc50\ud835\udc4e\ud835\udc59\ud835\udc36\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60\ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc5c\ud835\udc5d\ud835\udc66+\ud835\udf06\u2217\ud835\udc36\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc52\ud835\udc5f\ud835\udc3f\ud835\udc5c\ud835\udc60\ud835\udc60 \ud835\udc36\ud835\udc4e\ud835\udc61\ud835\udc52\ud835\udc54\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc50\ud835\udc4e\ud835\udc59\ud835\udc36\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60\ud835\udc38\ud835\udc5b\ud835\udc61\ud835\udc5f\ud835\udc5c\ud835\udc5d\ud835\udc66+\ud835\udf06\u2217\ud835\udc36\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc52\ud835\udc5f\ud835\udc3f\ud835\udc5c\ud835\udc60\ud835\udc60",
            "title": "Center Loss"
        },
        {
            "location": "/tutorial II - Write Your Own Module/#center-module",
            "text": "Now we\u2019ll go through the code part to illustrate how the center loss can be actually computed. To compute the center loss, we need first to get the center estimation of each class. This is done through a new module referred as  Center . Check the code snippet following.  class Center(Module):\n    \"\"\"\n    Compute the class centers during training\n    Ref. to \"Discriminative feature learning approach for deep face recognition (2016)\"\n    \"\"\"\n    def __init__(self, feature_dim, center_num, alpha=0.9, center=init.GlorotUniform(), name=None):\n        \"\"\"\n        :param alpha: moving averaging coefficient\n        :param center: initial value of center\n        \"\"\"\n        super().__init__(name=name)\n        self.center = self.register_self_updating_variable(center, shape=[center_num, feature_dim], name=\"center\")\n        self.alpha = alpha\n\n    def forward(self, features, labels):\n        \"\"\"\n        :param features: (B, D)\n        :param labels: (B,)\n        :return: categorical centers\n        \"\"\"\n        center_batch = self.center[labels, :]\n        diff = (self.alpha - 1.0) * (center_batch - features)\n        center_updated = tensor.inc_subtensor(self.center[labels, :], diff)\n        self.center.default_update = center_updated\n        return self.center\n\n    def predict(self):\n        return self.center  First, all our NN modules should subclass the root  Module  class, then we can use class methods and attributes to manipulate network parameters conveniently.  Second, define the module initialization in  .__init__()  part. Here we do two things: we register a  center  tensor as network parameter and initialize it with a Glorot uniform random numpy array. The  center  tensor is of shape  (center_num, feature_dim) , in which  center_num  should be equal to class number, and  feature_dim  is the dimension of extracted features by the network.  In Dandelion, the network parameters are divided into two categories:     1) parameter to be updated by optimizer,    2) parameter to updated by user defined expression.   The former parameters should be registered with class method  .register_param() , and the latter parameters should be registered with class method  . register_self_updating_variable() .  Now we registered  center  tensor as self updating variable, its updating expression is given in  .forward()  function as  self.center.update = center_updated . In Dandelion we use a specially named attribute  . update  to tell the framework that this parameter has an updating expression defined and the updating expression will be collected during Theano function compiling phase.  The  .forward()  function will be used for training, and  .predict()  function will be used for inference.   Basically, during training, the  .forward()  function computes moving averaging estimation of class centers; and during inference, we just use the stored center values as final estimated class centers. This is pretty much alike how  BatchNorm \u2019s mean and std are estimated and used.",
            "title": "Center Module"
        },
        {
            "location": "/tutorial II - Write Your Own Module/#summary",
            "text": "To summary, to write your own module, you only need to do the following three steps:   1) subclass  Module  class  2) register your module\u2019s parameters by  .register_param()  or  . register_self_updating_variable()  and initialize them  3) define the  .forward()  function for training and  .predict()  function for inference   and that\u2019s it!",
            "title": "Summary"
        },
        {
            "location": "/howtos/",
            "text": "Tutorial III: Howtos\n\n\n1) How to freeze a module during training like in Keras/Lasagne?\n\n\nTo \nfreeze\n a module during training, use the \ninclude\n and \nexclude\n arguments of module's \n.collect_params()\n and \n.collect_self_updates()\n functions.\n\n\nExample\n\n\nclass FOO(Module):\n    def __init__(self):\n        self.cnn0 = Conv2D(...)\n        self.cnn1 = Conv2D(...)\n        self.cnn2 = Conv2D(...)\n        ....\n\n# Now we will freeze cnn0 and cnn1 submodules during training\nmodel    = Foo()\nloss     = ...\nparams   = model.collect_params(exclude=['cnn0', 'cnn1'])\nupdates  = optimizer(loss, params)\nupdates.update(model.colect_self_updates(exclude=['cnn0', 'cnn1']))\ntrain_fn = theano.function([...], [...], updates=updates, no_default_updates=False)\n\n\n\n\n2) How to add random noise to a tensor?\n\n\nJust use Theano's \nMRG_RandomStreams\n module.\n\n\nExample\n\n\nfrom theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams\nsrng = RandomStreams(np.random.randint(1, 2147462579))\n....\ny = x + srng.normal(x.shape, avg=0.0, std=0.1)   # add Gaussian noise to x\n\n\n\n\nWhat you'd keep in mind is that if you used Theano's \nMRG_RandomStreams\n module, remember to set \nno_default_updates=False\n when compiling functions.",
            "title": "III - Howtos"
        },
        {
            "location": "/howtos/#tutorial-iii-howtos",
            "text": "",
            "title": "Tutorial III: Howtos"
        },
        {
            "location": "/howtos/#1-how-to-freeze-a-module-during-training-like-in-keraslasagne",
            "text": "To  freeze  a module during training, use the  include  and  exclude  arguments of module's  .collect_params()  and  .collect_self_updates()  functions.",
            "title": "1) How to freeze a module during training like in Keras/Lasagne?"
        },
        {
            "location": "/howtos/#example",
            "text": "class FOO(Module):\n    def __init__(self):\n        self.cnn0 = Conv2D(...)\n        self.cnn1 = Conv2D(...)\n        self.cnn2 = Conv2D(...)\n        ....\n\n# Now we will freeze cnn0 and cnn1 submodules during training\nmodel    = Foo()\nloss     = ...\nparams   = model.collect_params(exclude=['cnn0', 'cnn1'])\nupdates  = optimizer(loss, params)\nupdates.update(model.colect_self_updates(exclude=['cnn0', 'cnn1']))\ntrain_fn = theano.function([...], [...], updates=updates, no_default_updates=False)",
            "title": "Example"
        },
        {
            "location": "/howtos/#2-how-to-add-random-noise-to-a-tensor",
            "text": "Just use Theano's  MRG_RandomStreams  module.",
            "title": "2) How to add random noise to a tensor?"
        },
        {
            "location": "/howtos/#example_1",
            "text": "from theano.sandbox.rng_mrg import MRG_RandomStreams as RandomStreams\nsrng = RandomStreams(np.random.randint(1, 2147462579))\n....\ny = x + srng.normal(x.shape, avg=0.0, std=0.1)   # add Gaussian noise to x  What you'd keep in mind is that if you used Theano's  MRG_RandomStreams  module, remember to set  no_default_updates=False  when compiling functions.",
            "title": "Example"
        },
        {
            "location": "/dandelion_module/",
            "text": "Module\n\n\nRoot class of all network modules, you'd always subclass this for a new module\n\n\nclass Module(name=None, work_mode='inference')\n\n\n\n\n\n\nname\n: module name, optional. If you don't specify the module name, it will be auto-named if this module is a sub-module of another module.\n\n\nwork_mode\n: working mode, optional. Only used for the unified calling interface, check \"Tutorial I\" for detailed explanation.\n\n\n\n\n.params                  = []  \n.self_updating_variables = [] \n.sub_modules             = OrderedDict()\n.name                    = name\n.work_mode               = work_mode\n\n\n\n\n\n\nparams\n: contains all the parameters which should be updated by optimizer (submodule excluded)\n\n\nself_updating_variables\n: contains all the parameters which are updated by user specified expression (submoduluded)\n\n\nsub_modules\n: contains all the sub-modules\n\n\n\n\n.register_param(x, shape=None, name=None)\n.register_self_updating_variable(x, shape=None, name=None)\n\n\n\n\nRegister and possibly initialize a parameter tensor. Parameters to be updated by optimizer should be registered with \nregister_param()\n meanwhile parameters self-updated should be registerd with \nregister_self_updating_variable()\n\n\n\n\nx\n: Theano shared variable, expression, numpy array or callable. Initial value, expression or initializer for this parameter.\n\n\nshape\n: tuple of int, optional. A tuple of integers representing the desired shape of the parameter tensor.\n\n\nname\n: str, optional. It's recommended to let the Dandelion framework name the variable automatically.\n\n\n\n\n.collect_params(include=None, exclude=None, include_self=True)\n\n\n\n\nCollect parameters to be updated by optimizer.\n\n\n\n\ninclude\n: sub-module keys, means which sub-module to include\n\n\nexclude\n: sub-module keys, means which sub-module to exclude\n\n\ninclude_self\n: whether include \nself.params\n\n\nreturn\n: list of parameters, in the same order of sub-modules\n\n\n\n\n.collect_self_updates(include=None, exclude=None, include_self=True)\n\n\n\n\nCollect all \nupdate\n from self_updating_variables.\n\n\n\n\ninclude\n: sub-module keys, means which sub-module to include\n\n\nexclude\n: sub-module keys, means which sub-module to exclude\n\n\ninclude_self\n: whether include \nself.self_updating_variables\n\n\nreturn\n: update dict, in the same order of sub-modules\n\n\n\n\n.get_weights()\n\n\n\n\nCollect all module weights (including submodules)\n\n\n\n\nreturn\n: list of tuples with format [variable.value, variable.name]\n\n\n\n\n.set_weights(module_weights, check_name='ignore')\n\n\n\n\nSet module weights by default order (same order with \n.get_weights()\n)\n\n\n\n\nmodule_weights\n: same with the return of \n.get_weights()\n\n\ncheck_name\n: \nignore\n|\nwarn\n|\nraise\n. What to do if a weight's name does not match its corresponding variable's name.\n\n\n\n\n.set_weights_by_name(module_weights, unmatched='raise')\n\n\n\n\nSet module weights by matching name.\n\n\n\n\nmodule_weights\n: same with the return of \n.get_weights()\n\n\nunmatched\n:  \nignore\n|\nwarn\n|\nraise\n. What to do if there remain weights or module variables unmatched.\n\n\n\n\n\n\nDropout\n\n\nSets values to zero with probability \np\n\n\nclass Dropout(seed=None, name=None)\n\n\n\n\n\n\nseed\n: the random seed (integer) for initialization, optional\n\n\n\n\n.forward(input, p=0.5, shared_axes=(), rescale=True)\n\n\n\n\n\n\np\n: \ufb02oat or scalar tensor. The probability of setting a value to zero\n\n\nshared_axes\n: tuple of int. Axes to share the dropout mask over. By default, each value can be dropped individually. \nshared_axes\n=(0,) uses the same mask across the batch. \nshared_axes\n=(2, 3) uses the same mask across the spatial dimensions of 2D feature maps.\n\n\nrescale\n: bool. If True (the default), scale the input by 1 / (1 - \np\n) when dropout is enabled, to keep the expected output mean the same.\n\n\n\n\n.predict( input, *args, **kwargs)\n\n\n\n\ndummy interface, does nothing but returns the input unchanged.\n\n\nNote: Theano uses \nself_update\n mechanism to implement pseudo randomness, so to use \nDropout\n class, the followings are recommened:\n\n\n\n\n(1) define different instance for each droput layer\n\n\n(2) compiling function with \nno_default_updates=False\n\n\n\n\n\n\nGRU\n\n\nGated Recurrent Unit RNN.\n\n\nclass GRU(input_dims, hidden_dim, initializer=init.Normal(0.1), grad_clipping=0, \n          hidden_activation=tanh, learn_ini=False, truncate_gradient=-1, name=None)\n\n\n\n\n\n\ninput_dims\n: integer or list of integers. If scalar, input dimension = \ninput_dims\n; if list of integers, input dimension = sum(\ninput_dims\n), and GRU\u2019s parameter \nW_in\n will be initialized unevenly by integers specified in input_dims\n\n\nhidden_dim\n: dimension of hidden units, also the output dimension\n\n\ngrad_clipping\n: float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping\n\n\nhidden_activation\n: nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use \ntanh\n as default.\n\n\nlearn_ini\n: whether learn initial state\n\n\ntruncate_gradient\n: if not -1, BPTT will be used, gradient back-propagation will be performed at most \ntruncate_gradient\n steps\n\n\n\n\n.forward(seq_input, h_ini=None, seq_mask=None, backward=False, only_return_final=False, return_final_state=False)\n\n\n\n\n\n\nseq_input\n: tensor with shape (T, B, D) in which D is the input dimension\n\n\nh_ini\n: initialization of hidden cell, (B, hidden_dim)\n\n\nseq_mask\n: mask for \nseq_input\n\n\nbackward\n: bool. Whether scan in backward direction\n\n\nonly_return_final\n: bool. If \nTrue\n, only return the \ufb01nal sequential output (e.g. for tasks where a single target value for the entire sequence is desired). In this case, Theano makes an optimization which saves memory.\n\n\nreturn_final_state\n: If \nTrue\n, the final state of \nhidden\n and \ncell\n will be returned, both (B, hidden_dim)\n\n\n\n\n.predict = .forward\n\n\n\n\n\n\nLSTM\n\n\nLong Short-Term Memory RNN\n\n\nclass LSTM( input_dims, hidden_dim, peephole=True, initializer=init.Normal(0.1), grad_clipping=0, \n            hidden_activation=tanh, learn_ini=False, truncate_gradient=-1, name=None)\n\n\n\n\n\n\ninput_dims\n: integer or list of integers. If scalar, input dimension = \ninput_dims\n; if list of integers, input dimension = sum(\ninput_dims\n), and LSTM\u2019s parameter \nW_in\n will be initialized unevenly by integers specified in input_dims\n\n\nhidden_dim\n: dimension of hidden units, also the output dimension\n\n\npeephole\n: bool. Whether add peephole connection.\n\n\ngrad_clipping\n: float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping\n\n\nhidden_activation\n: nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use \ntanh\n as default.\n\n\nlearn_ini\n: whether learn initial state\n\n\ntruncate_gradient\n: if not -1, BPTT will be used, gradient back-propagation will be performed at most \ntruncate_gradient\n steps\n\n\n\n\n.forward(seq_input, h_ini=None, c_ini=None, seq_mask=None, backward=False, only_return_final=False, return_final_state=False)\n\n\n\n\n\n\nseq_input\n: tensor with shape (T, B, D) in which D is the input dimension\n\n\nh_ini\n: initialization of hidden state, (B, hidden_dim)\n\n\nc_ini\n: initialization of cell state, (B, hidden_dim)\n\n\nseq_mask\n: mask for seq_input\n\n\nbackward\n: bool. Whether scan in backward direction\n\n\nonly_return_final\n: bool. If \nTrue\n, only return the \ufb01nal sequential output (e.g. for tasks where a single target value for the entire sequence is desired). In this case, Theano makes an optimization which saves memory.\n\n\nreturn_final_state\n: If \nTrue\n, the final state of \nhidden\n and \ncell\n will be returned, both (B, hidden_dim)\n\n\n\n\n.predict = .forward\n\n\n\n\n\n\nGRUCell\n\n\nGated Recurrent Unit RNN Cell\n\n\nclass GRUCell(input_dims, hidden_dim, initializer=init.Normal(0.1), grad_clipping=0, \n              hidden_activation=tanh, name=None)\n\n\n\n\n\n\ninput_dims\n: integer or list of integers. If scalar, input dimension = \ninput_dims\n; if list of integers, input dimension = sum(\ninput_dims\n), and GRUCell\u2019s parameter \nW_in\n will be initialized unevenly by integers specified in input_dims\n\n\nhidden_dim\n: dimension of hidden units, also the output dimension\n\n\ngrad_clipping\n: float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping\n\n\nhidden_activation\n: nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use \ntanh\n as default\n\n\n\n\n.forward(input, h_pre, mask=None)\n\n\n\n\n\n\ninput\n: tensor with shape (B, D) in which D is the input dimension\n\n\nh_pre\n: initialization of hidden cell, (B, hidden_dim)\n\n\nmask\n: mask for \ninput\n\n\n\n\n.predict = .forward\n\n\n\n\n\n\nLSTMCell\n\n\nLong Short-Term Memory RNN Cell\n\n\nclass LSTMCell(input_dims, hidden_dim, peephole=True, initializer=init.Normal(0.1), grad_clipping=0, \n               hidden_activation=tanh, name=None)\n\n\n\n\n\n\ninput_dims\n: integer or list of integers. If scalar, input dimension = \ninput_dims\n; if list of integers, input dimension = sum(\ninput_dims\n), and LSTM\u2019s parameter \nW_in\n will be initialized unevenly by integers specified in input_dims\n\n\nhidden_dim\n: dimension of hidden units, also the output dimension\n\n\npeephole\n: bool. Whether add peephole connection.\n\n\ngrad_clipping\n: float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping\n\n\nhidden_activation\n: nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use \ntanh\n as default.\n\n\n\n\n.forward(input, h_pre, c_pre, mask=None)\n\n\n\n\n\n\ninput\n: tensor with shape (B, D) in which D is the input dimension\n\n\nh_pre\n: initialization of hidden state, (B, hidden_dim)\n\n\nc_pre\n: initialization of cell state, (B, hidden_dim)\n\n\nmask\n: mask for \ninput\n\n\n\n\n.predict = .forward\n\n\n\n\n\n\nConv2D\n\n\nConvolution 2D\n\n\nclass Conv2D(in_channels, out_channels, kernel_size=(3,3), stride=(1,1), pad='valid', \n             dilation=(1,1), num_groups=1, W=init.GlorotUniform(), b=init.Constant(0.), \n             flip_filters=True, convOP=tensor.nnet.conv2d, input_shape=(None,None), untie_bias=False, name=None)\n\n\n\n\n\n\ninput_channels\n: int. Input shape of Conv2D module is (B, input_channels, H_in, W_in)\n\n\nout_channels\n: int. Output shape of Conv2D module is (B output_channels, H_out, W_out)\n\n\nkernel_size\n: int scalar or tuple of int. Convolution kernel size\n\n\nstride\n: Factor by which to subsample the output\n\n\npad\n: \nsame\n/\nvalid\n/\nfull\n or 2-element tuple of int. Control image border padding.\n\n\ndilation\n: factor by which to subsample (stride) the input.\n\n\nnum_groups\n: Divides the image, kernel and output tensors into num_groups separate groups. Each which carry out convolutions separately\n\n\nW\n: initialization of filter bank, shape = (out_channels, in_channels, kernel_size[0], kernel_size[1])\n\n\nb\n: initialization of convolution bias, shape = (out_channels,) if untie_bias is False; otherwise shape = (out_channels, H_out, W_out)\n\n\nflip_filters\n: If \nTrue\n, will flip the filter rows and columns before sliding them over the input. This operation is normally referred to as a convolution, and this is the default. If \nFalse\n, the filters are not flipped and the operation is referred to as a cross-correlation.\n\n\ninput_shape\n: optional, (H_in, W_in)\n\n\nuntie_bias\n: If \nFalse\n, the module will have a bias parameter for each channel, which is shared across all positions in this channel. As a result, the b attribute will be a vector (1D). If \nTrue\n, the module will have separate bias parameters for each position in each channel. As a result, the b attribute will be a 3D tensor.\n\n\n\n\n\n\nConvTransposed2D\n\n\nTransposed convolution 2D. Also known as fractionally-strided convolution or deconvolution (although it is not an actual deconvolution operation)\n\n\nclass ConvTransposed2D(in_channels, out_channels, kernel_size=(3,3), stride=(1,1), pad='valid', \n                       dilation=(1,1), num_groups=1, W=init.GlorotUniform(), b=init.Constant(0.), \n                       flip_filters=True, input_shape=(None,None), untie_bias=False, name=None)\n\n\n\n\n\n\nreturn\n: output shape = \n(B, C, H, W)\n, in which \nH = ((H_in - 1) * stride_H) + kernel_H - 2 * pad_H\n, and the same with \nW\n.\n\n\n\n\nAll the parameters have the same meanings with \nConv2D\n module. In fact, the transposed convolution is equal to upsampling the input then doing conventional convolution. However, for efficiency purpose, here the transposed convolution is implemented via Theano\u2019s \nAbstractConv2d_gradInputs\n as what is done in Lasagne.\n\n\n\n\nDense\n\n\nFully connected network, also known as affine transform. Apply affine transform \nWx+b\n to the last dimension of input.\n\nThe input of \nDense\n can have any dimensions, and note that we do not apply any activation to its output by default\n\n\nclass Dense(input_dims, output_dim, W=init.GlorotUniform(), b=init.Constant(0.), name=None)\n\n\n\n\n\n\ninput_dims\n: integer or list of integers. If scalar, input dimension = input_dims; if list of integers, input dimension = sum(input_dims), and Dense\u2019s parameter \nW\n will be initialized unevenly by integers specified in input_dims\n\n\noutput_dim\n: output dimension\n\n\nW\n, \nb\n: parameter initialization\n\n\n\n\n\n\nEmbedding\n\n\nWord/character embedding module.\n\n\nclass Embedding(num_embeddings, embedding_dim, W=init.Normal(), name=None)\n\n\n\n\n\n\nnum_embeddings\n: the Number of different embeddings\n\n\nembedding_dim\n: output embedding vector dimension\n\n\n\n\n\n\nBatchNorm\n\n\nBatch normalization module.\n\n\nclass BatchNorm(input_shape=None, axes='auto', eps=1e-4, alpha=0.1, beta=init.Constant(0), gamma=init.Constant(1), \n                mean=init.Constant(0), inv_std=init.Constant(1), mode='high_mem', name=None)\n\n\n\n\n\n\ninput_shape\n: Tuple or list of ints or tensor variables. Input shape of \nBatchNorm\n module, including batch dimension. \n\n\naxes\n: \nauto\n or tuple of int. The axis or axes to normalize over. If \nauto\n (the default), normalize over all axes except for the second: this will normalize over the minibatch dimension for dense layers, and additionally over all spatial dimensions for convolutional layers.\n\n\neps\n: Small constant \ud835\udf16 added to the variance before taking the square root and dividing by it, to avoid numerical problems\n\n\nalpha\n: Coefficient for the exponential moving average of batch-wise means and standard deviations computed during training; the closer to one, the more it will depend on the last batches seen\n\n\nmode\n: \nlow_mem\n or \nhigh_mem\n. Specify which batch normalization implementation that will be used. As no intermediate representations are stored for the back-propagation, \nlow_mem\n implementation lower the memory usage, however, it is 5-10% slower than \nhigh_mem\n implementation. Note that 5-10% computation time difference compare the batch normalization operation only, time difference between implementation is likely to be less important on the full model fprop/bprop.\n\n\n\n\n.forward(input, use_input_mean=True)\n\n\n\n\n\n\nuse_input_mean\n: default, use mean & std of input batch for normalization; if \nFalse\n, \nself.mean\n and \nself.std\n will be used for normalization. The reason that input mean is used during training is because at the early training stage, \nBatchNorm\n's \nself.mean\n is far from the expected mean value and can be detrimental for network convergence. It's recommended to use input mean for early stage training; after that, you can switch to \nBatchNorm\n's \nself.mean\n for training & inference consistency.\n\n\n\n\n\n\nCenter\n\n\nEstimate class centers by moving averaging.\n\n\nclass Center(feature_dim, center_num, center=init.GlorotUniform(), name=None)\n\n\n\n\n\n\nfeature_dim\n: feature dimension \n\n\ncenter_num\n: class center number\n\n\ncenter\n: initialization of class centers, should be in shape of \n(center_num, feature_dim)\n\n\n\n\n.forward(features, labels, alpha=0.1)\n\n\n\n\n\n\nfeatures\n: batch features, from which the class centers will be estimated\n\n\nlabels\n: \nfeatures\n's corresponding class labels\n\n\nalpha\n: moving averaging coefficient, the closer to one, the more it will depend on the last batches seen: \nC_{new} = \\alpha*C_{batch} + (1-\\alpha)*C_{old}\nC_{new} = \\alpha*C_{batch} + (1-\\alpha)*C_{old}\n\n\nreturn\n: centers estimated\n\n\n\n\n.predict()\n\n\n\n\n\n\nreturn\n: centers stored\n\n\n\n\n\n\nChainCRF\n\n\nLinear chain CRF layer for sequence labeling.\n\n\nclass ChainCRF(state_num, transitions=init.GlorotUniform(), p_scale=1.0, l1_regularization=0.001, \n               state_pad=True, transition_matrix_normalization=True,  name=None)\n\n\n\n\n\n\nstate_num\n: number of hidden states. If \nstate_pad\n is \nTrue\n, then the actual state number inside CRF will be \nstate_num + 2\n.\n\n\ntransitions\n: initialization of transition matrix, in shape of \n(state_num+2, state_num+2)\n if \nstate_pad\n is \nTrue\n, else \n(state_num, state_num)\n\n\np_scale\n: probability scale factor. The input of this module will be multiplied by this factor.\n\n\nl1_regularization\n: L1 regularization coefficient for \ntransition\n matrix\n\n\nstate_pad\n: whether do state padding. CRF requires two additional dummy states, i.e., \n<bos>\n and \n<eos>\n (beginning and endding of sequence). The \nChainCRF\n module can pad the state automatically with these two dummy states, or you can incorporate these two states in module input. In the latter case, set \nstate_pad\n to \nFalse\n.\n\n\ntransition_matrix_normalization\n: whether do row-wise normalization of transition matrix. You may expect that each row of the \ntransition\n matrix should sum to 1.0, and to do this, set this flag to \nTrue\n.\n\n\n\n\n.forward(x, y)\n\n\n\n\nCompute CRF loss\n\n\n\n\nx\n: output from previous RNN layer, in shape of (B, T, N)\n\n\ny\n: tag ground truth, in shape of (B, T), int32\n\n\nreturn\n: loss in shape of (B,) if \nl1_regularization\n disabled, else in shape of (1,)\n\n\n\n\n.predict(x)\n\n\n\n\nCRF Viterbi decoding\n\n\n\n\nx\n: output from previous RNN layer, in shape of (B, T, N)\n\n\nreturn\n: decoded sequence\n\n\n\n\n\n\nSequential\n\n\nSequential container for a list of modules, just for convenience.\n\n\nclass Sequential(module_list, activation=linear, name=None)\n\n\n\n\n\n\nmodule_list\n: list of network sub-modules, these modules \nMUST NOT\n be sub-modules of any other parent module.\n\n\nactivation\n: activation applied to output of each sub-module.\n\n\n\n\n.forward(x)\n\n\n\n\nForward pass through the network module sequence.\n\n\n.predict(x)\n\n\n\n\nInference pass through the network module sequence.\n\n\nExample:\n\n\n        conv1 = Conv2D(in_channels=1, out_channels=3, stride=(2,2))\n        bn1   = BatchNorm(input_shape=(None, 3, None, None))\n        conv2 = Conv2D(in_channels=3, out_channels=5)\n        conv3 = Conv2D(in_channels=5, out_channels=8)\n        model = Sequential([conv1, bn1, conv2, conv3], activation=relu, name='Seq')\n\n        x = tensor.ftensor4('x')\n        y = model.forward(x)\n        print('compiling fn...')\n        fn = theano.function([x], y, no_default_updates=False)\n        print('run fn...')\n        input = np.random.rand(4, 1, 32, 33).astype(np.float32)\n        output = fn(input)\n        print(output)",
            "title": "dandelion.module"
        },
        {
            "location": "/dandelion_module/#module",
            "text": "Root class of all network modules, you'd always subclass this for a new module  class Module(name=None, work_mode='inference')   name : module name, optional. If you don't specify the module name, it will be auto-named if this module is a sub-module of another module.  work_mode : working mode, optional. Only used for the unified calling interface, check \"Tutorial I\" for detailed explanation.   .params                  = []  \n.self_updating_variables = [] \n.sub_modules             = OrderedDict()\n.name                    = name\n.work_mode               = work_mode   params : contains all the parameters which should be updated by optimizer (submodule excluded)  self_updating_variables : contains all the parameters which are updated by user specified expression (submoduluded)  sub_modules : contains all the sub-modules   .register_param(x, shape=None, name=None)\n.register_self_updating_variable(x, shape=None, name=None)  Register and possibly initialize a parameter tensor. Parameters to be updated by optimizer should be registered with  register_param()  meanwhile parameters self-updated should be registerd with  register_self_updating_variable()   x : Theano shared variable, expression, numpy array or callable. Initial value, expression or initializer for this parameter.  shape : tuple of int, optional. A tuple of integers representing the desired shape of the parameter tensor.  name : str, optional. It's recommended to let the Dandelion framework name the variable automatically.   .collect_params(include=None, exclude=None, include_self=True)  Collect parameters to be updated by optimizer.   include : sub-module keys, means which sub-module to include  exclude : sub-module keys, means which sub-module to exclude  include_self : whether include  self.params  return : list of parameters, in the same order of sub-modules   .collect_self_updates(include=None, exclude=None, include_self=True)  Collect all  update  from self_updating_variables.   include : sub-module keys, means which sub-module to include  exclude : sub-module keys, means which sub-module to exclude  include_self : whether include  self.self_updating_variables  return : update dict, in the same order of sub-modules   .get_weights()  Collect all module weights (including submodules)   return : list of tuples with format [variable.value, variable.name]   .set_weights(module_weights, check_name='ignore')  Set module weights by default order (same order with  .get_weights() )   module_weights : same with the return of  .get_weights()  check_name :  ignore | warn | raise . What to do if a weight's name does not match its corresponding variable's name.   .set_weights_by_name(module_weights, unmatched='raise')  Set module weights by matching name.   module_weights : same with the return of  .get_weights()  unmatched :   ignore | warn | raise . What to do if there remain weights or module variables unmatched.",
            "title": "Module"
        },
        {
            "location": "/dandelion_module/#dropout",
            "text": "Sets values to zero with probability  p  class Dropout(seed=None, name=None)   seed : the random seed (integer) for initialization, optional   .forward(input, p=0.5, shared_axes=(), rescale=True)   p : \ufb02oat or scalar tensor. The probability of setting a value to zero  shared_axes : tuple of int. Axes to share the dropout mask over. By default, each value can be dropped individually.  shared_axes =(0,) uses the same mask across the batch.  shared_axes =(2, 3) uses the same mask across the spatial dimensions of 2D feature maps.  rescale : bool. If True (the default), scale the input by 1 / (1 -  p ) when dropout is enabled, to keep the expected output mean the same.   .predict( input, *args, **kwargs)  dummy interface, does nothing but returns the input unchanged.  Note: Theano uses  self_update  mechanism to implement pseudo randomness, so to use  Dropout  class, the followings are recommened:   (1) define different instance for each droput layer  (2) compiling function with  no_default_updates=False",
            "title": "Dropout"
        },
        {
            "location": "/dandelion_module/#gru",
            "text": "Gated Recurrent Unit RNN.  class GRU(input_dims, hidden_dim, initializer=init.Normal(0.1), grad_clipping=0, \n          hidden_activation=tanh, learn_ini=False, truncate_gradient=-1, name=None)   input_dims : integer or list of integers. If scalar, input dimension =  input_dims ; if list of integers, input dimension = sum( input_dims ), and GRU\u2019s parameter  W_in  will be initialized unevenly by integers specified in input_dims  hidden_dim : dimension of hidden units, also the output dimension  grad_clipping : float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping  hidden_activation : nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use  tanh  as default.  learn_ini : whether learn initial state  truncate_gradient : if not -1, BPTT will be used, gradient back-propagation will be performed at most  truncate_gradient  steps   .forward(seq_input, h_ini=None, seq_mask=None, backward=False, only_return_final=False, return_final_state=False)   seq_input : tensor with shape (T, B, D) in which D is the input dimension  h_ini : initialization of hidden cell, (B, hidden_dim)  seq_mask : mask for  seq_input  backward : bool. Whether scan in backward direction  only_return_final : bool. If  True , only return the \ufb01nal sequential output (e.g. for tasks where a single target value for the entire sequence is desired). In this case, Theano makes an optimization which saves memory.  return_final_state : If  True , the final state of  hidden  and  cell  will be returned, both (B, hidden_dim)   .predict = .forward",
            "title": "GRU"
        },
        {
            "location": "/dandelion_module/#lstm",
            "text": "Long Short-Term Memory RNN  class LSTM( input_dims, hidden_dim, peephole=True, initializer=init.Normal(0.1), grad_clipping=0, \n            hidden_activation=tanh, learn_ini=False, truncate_gradient=-1, name=None)   input_dims : integer or list of integers. If scalar, input dimension =  input_dims ; if list of integers, input dimension = sum( input_dims ), and LSTM\u2019s parameter  W_in  will be initialized unevenly by integers specified in input_dims  hidden_dim : dimension of hidden units, also the output dimension  peephole : bool. Whether add peephole connection.  grad_clipping : float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping  hidden_activation : nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use  tanh  as default.  learn_ini : whether learn initial state  truncate_gradient : if not -1, BPTT will be used, gradient back-propagation will be performed at most  truncate_gradient  steps   .forward(seq_input, h_ini=None, c_ini=None, seq_mask=None, backward=False, only_return_final=False, return_final_state=False)   seq_input : tensor with shape (T, B, D) in which D is the input dimension  h_ini : initialization of hidden state, (B, hidden_dim)  c_ini : initialization of cell state, (B, hidden_dim)  seq_mask : mask for seq_input  backward : bool. Whether scan in backward direction  only_return_final : bool. If  True , only return the \ufb01nal sequential output (e.g. for tasks where a single target value for the entire sequence is desired). In this case, Theano makes an optimization which saves memory.  return_final_state : If  True , the final state of  hidden  and  cell  will be returned, both (B, hidden_dim)   .predict = .forward",
            "title": "LSTM"
        },
        {
            "location": "/dandelion_module/#grucell",
            "text": "Gated Recurrent Unit RNN Cell  class GRUCell(input_dims, hidden_dim, initializer=init.Normal(0.1), grad_clipping=0, \n              hidden_activation=tanh, name=None)   input_dims : integer or list of integers. If scalar, input dimension =  input_dims ; if list of integers, input dimension = sum( input_dims ), and GRUCell\u2019s parameter  W_in  will be initialized unevenly by integers specified in input_dims  hidden_dim : dimension of hidden units, also the output dimension  grad_clipping : float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping  hidden_activation : nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use  tanh  as default   .forward(input, h_pre, mask=None)   input : tensor with shape (B, D) in which D is the input dimension  h_pre : initialization of hidden cell, (B, hidden_dim)  mask : mask for  input   .predict = .forward",
            "title": "GRUCell"
        },
        {
            "location": "/dandelion_module/#lstmcell",
            "text": "Long Short-Term Memory RNN Cell  class LSTMCell(input_dims, hidden_dim, peephole=True, initializer=init.Normal(0.1), grad_clipping=0, \n               hidden_activation=tanh, name=None)   input_dims : integer or list of integers. If scalar, input dimension =  input_dims ; if list of integers, input dimension = sum( input_dims ), and LSTM\u2019s parameter  W_in  will be initialized unevenly by integers specified in input_dims  hidden_dim : dimension of hidden units, also the output dimension  peephole : bool. Whether add peephole connection.  grad_clipping : float. Hard clip the gradients at each time step. Only the gradient values above this threshold are clipped to the threshold. This is done during backprop. Some works report that using grad_normalization is better than grad_clipping  hidden_activation : nonlinearity applied to hidden variable, i.e., h = hidden_activation(cell). It's recommended to use  tanh  as default.   .forward(input, h_pre, c_pre, mask=None)   input : tensor with shape (B, D) in which D is the input dimension  h_pre : initialization of hidden state, (B, hidden_dim)  c_pre : initialization of cell state, (B, hidden_dim)  mask : mask for  input   .predict = .forward",
            "title": "LSTMCell"
        },
        {
            "location": "/dandelion_module/#conv2d",
            "text": "Convolution 2D  class Conv2D(in_channels, out_channels, kernel_size=(3,3), stride=(1,1), pad='valid', \n             dilation=(1,1), num_groups=1, W=init.GlorotUniform(), b=init.Constant(0.), \n             flip_filters=True, convOP=tensor.nnet.conv2d, input_shape=(None,None), untie_bias=False, name=None)   input_channels : int. Input shape of Conv2D module is (B, input_channels, H_in, W_in)  out_channels : int. Output shape of Conv2D module is (B output_channels, H_out, W_out)  kernel_size : int scalar or tuple of int. Convolution kernel size  stride : Factor by which to subsample the output  pad :  same / valid / full  or 2-element tuple of int. Control image border padding.  dilation : factor by which to subsample (stride) the input.  num_groups : Divides the image, kernel and output tensors into num_groups separate groups. Each which carry out convolutions separately  W : initialization of filter bank, shape = (out_channels, in_channels, kernel_size[0], kernel_size[1])  b : initialization of convolution bias, shape = (out_channels,) if untie_bias is False; otherwise shape = (out_channels, H_out, W_out)  flip_filters : If  True , will flip the filter rows and columns before sliding them over the input. This operation is normally referred to as a convolution, and this is the default. If  False , the filters are not flipped and the operation is referred to as a cross-correlation.  input_shape : optional, (H_in, W_in)  untie_bias : If  False , the module will have a bias parameter for each channel, which is shared across all positions in this channel. As a result, the b attribute will be a vector (1D). If  True , the module will have separate bias parameters for each position in each channel. As a result, the b attribute will be a 3D tensor.",
            "title": "Conv2D"
        },
        {
            "location": "/dandelion_module/#convtransposed2d",
            "text": "Transposed convolution 2D. Also known as fractionally-strided convolution or deconvolution (although it is not an actual deconvolution operation)  class ConvTransposed2D(in_channels, out_channels, kernel_size=(3,3), stride=(1,1), pad='valid', \n                       dilation=(1,1), num_groups=1, W=init.GlorotUniform(), b=init.Constant(0.), \n                       flip_filters=True, input_shape=(None,None), untie_bias=False, name=None)   return : output shape =  (B, C, H, W) , in which  H = ((H_in - 1) * stride_H) + kernel_H - 2 * pad_H , and the same with  W .   All the parameters have the same meanings with  Conv2D  module. In fact, the transposed convolution is equal to upsampling the input then doing conventional convolution. However, for efficiency purpose, here the transposed convolution is implemented via Theano\u2019s  AbstractConv2d_gradInputs  as what is done in Lasagne.",
            "title": "ConvTransposed2D"
        },
        {
            "location": "/dandelion_module/#dense",
            "text": "Fully connected network, also known as affine transform. Apply affine transform  Wx+b  to the last dimension of input. \nThe input of  Dense  can have any dimensions, and note that we do not apply any activation to its output by default  class Dense(input_dims, output_dim, W=init.GlorotUniform(), b=init.Constant(0.), name=None)   input_dims : integer or list of integers. If scalar, input dimension = input_dims; if list of integers, input dimension = sum(input_dims), and Dense\u2019s parameter  W  will be initialized unevenly by integers specified in input_dims  output_dim : output dimension  W ,  b : parameter initialization",
            "title": "Dense"
        },
        {
            "location": "/dandelion_module/#embedding",
            "text": "Word/character embedding module.  class Embedding(num_embeddings, embedding_dim, W=init.Normal(), name=None)   num_embeddings : the Number of different embeddings  embedding_dim : output embedding vector dimension",
            "title": "Embedding"
        },
        {
            "location": "/dandelion_module/#batchnorm",
            "text": "Batch normalization module.  class BatchNorm(input_shape=None, axes='auto', eps=1e-4, alpha=0.1, beta=init.Constant(0), gamma=init.Constant(1), \n                mean=init.Constant(0), inv_std=init.Constant(1), mode='high_mem', name=None)   input_shape : Tuple or list of ints or tensor variables. Input shape of  BatchNorm  module, including batch dimension.   axes :  auto  or tuple of int. The axis or axes to normalize over. If  auto  (the default), normalize over all axes except for the second: this will normalize over the minibatch dimension for dense layers, and additionally over all spatial dimensions for convolutional layers.  eps : Small constant \ud835\udf16 added to the variance before taking the square root and dividing by it, to avoid numerical problems  alpha : Coefficient for the exponential moving average of batch-wise means and standard deviations computed during training; the closer to one, the more it will depend on the last batches seen  mode :  low_mem  or  high_mem . Specify which batch normalization implementation that will be used. As no intermediate representations are stored for the back-propagation,  low_mem  implementation lower the memory usage, however, it is 5-10% slower than  high_mem  implementation. Note that 5-10% computation time difference compare the batch normalization operation only, time difference between implementation is likely to be less important on the full model fprop/bprop.   .forward(input, use_input_mean=True)   use_input_mean : default, use mean & std of input batch for normalization; if  False ,  self.mean  and  self.std  will be used for normalization. The reason that input mean is used during training is because at the early training stage,  BatchNorm 's  self.mean  is far from the expected mean value and can be detrimental for network convergence. It's recommended to use input mean for early stage training; after that, you can switch to  BatchNorm 's  self.mean  for training & inference consistency.",
            "title": "BatchNorm"
        },
        {
            "location": "/dandelion_module/#center",
            "text": "Estimate class centers by moving averaging.  class Center(feature_dim, center_num, center=init.GlorotUniform(), name=None)   feature_dim : feature dimension   center_num : class center number  center : initialization of class centers, should be in shape of  (center_num, feature_dim)   .forward(features, labels, alpha=0.1)   features : batch features, from which the class centers will be estimated  labels :  features 's corresponding class labels  alpha : moving averaging coefficient, the closer to one, the more it will depend on the last batches seen:  C_{new} = \\alpha*C_{batch} + (1-\\alpha)*C_{old} C_{new} = \\alpha*C_{batch} + (1-\\alpha)*C_{old}  return : centers estimated   .predict()   return : centers stored",
            "title": "Center"
        },
        {
            "location": "/dandelion_module/#chaincrf",
            "text": "Linear chain CRF layer for sequence labeling.  class ChainCRF(state_num, transitions=init.GlorotUniform(), p_scale=1.0, l1_regularization=0.001, \n               state_pad=True, transition_matrix_normalization=True,  name=None)   state_num : number of hidden states. If  state_pad  is  True , then the actual state number inside CRF will be  state_num + 2 .  transitions : initialization of transition matrix, in shape of  (state_num+2, state_num+2)  if  state_pad  is  True , else  (state_num, state_num)  p_scale : probability scale factor. The input of this module will be multiplied by this factor.  l1_regularization : L1 regularization coefficient for  transition  matrix  state_pad : whether do state padding. CRF requires two additional dummy states, i.e.,  <bos>  and  <eos>  (beginning and endding of sequence). The  ChainCRF  module can pad the state automatically with these two dummy states, or you can incorporate these two states in module input. In the latter case, set  state_pad  to  False .  transition_matrix_normalization : whether do row-wise normalization of transition matrix. You may expect that each row of the  transition  matrix should sum to 1.0, and to do this, set this flag to  True .   .forward(x, y)  Compute CRF loss   x : output from previous RNN layer, in shape of (B, T, N)  y : tag ground truth, in shape of (B, T), int32  return : loss in shape of (B,) if  l1_regularization  disabled, else in shape of (1,)   .predict(x)  CRF Viterbi decoding   x : output from previous RNN layer, in shape of (B, T, N)  return : decoded sequence",
            "title": "ChainCRF"
        },
        {
            "location": "/dandelion_module/#sequential",
            "text": "Sequential container for a list of modules, just for convenience.  class Sequential(module_list, activation=linear, name=None)   module_list : list of network sub-modules, these modules  MUST NOT  be sub-modules of any other parent module.  activation : activation applied to output of each sub-module.   .forward(x)  Forward pass through the network module sequence.  .predict(x)  Inference pass through the network module sequence.  Example:          conv1 = Conv2D(in_channels=1, out_channels=3, stride=(2,2))\n        bn1   = BatchNorm(input_shape=(None, 3, None, None))\n        conv2 = Conv2D(in_channels=3, out_channels=5)\n        conv3 = Conv2D(in_channels=5, out_channels=8)\n        model = Sequential([conv1, bn1, conv2, conv3], activation=relu, name='Seq')\n\n        x = tensor.ftensor4('x')\n        y = model.forward(x)\n        print('compiling fn...')\n        fn = theano.function([x], y, no_default_updates=False)\n        print('run fn...')\n        input = np.random.rand(4, 1, 32, 33).astype(np.float32)\n        output = fn(input)\n        print(output)",
            "title": "Sequential"
        },
        {
            "location": "/dandelion_functional/",
            "text": "pool_1d\n\n\nPooling 1 dimension along the given axis, support for any dimensional input.\n\n\npool_1d(x, ws=2, ignore_border=True, stride=None, pad=0, mode='max', axis=-1)\n\n\n\n\n\n\nws\n: scalar int. Factor by which to downsample the input\n\n\nignore_border\n: bool. When \nTrue\n, dimension size=5 with \nws\n=2 will generate a dimension size=2 output. 3 otherwise.\n\n\nstride\n: scalar int. The number of shifts over rows/cols to get the next pool region. If stride is None, it is considered equal to ws (no overlap on pooling regions), eg: \nstride\n=1 will shifts over one row for every iteration.\n\n\npad\n: pad zeros to extend beyond border of the input\n\n\nmode\n: {\nmax\n, \nsum\n, \naverage_inc_pad\n, \naverage_exc_pad\n}. Operation executed on each window. \nmax\n and \nsum\n always exclude the padding in the computation. \naverage\n gives you the choice to include or exclude it.\n\n\naxis\n: scalar int. Specify along which axis the pooling will be done\n\n\n\n\n\n\npool_2d\n\n\nPooling 2 dimension along the last 2 dimensions of input, support for any dimensional input with \nndim\n>=2.\n\n\npool_2d(x, ws=(2,2), ignore_border=True, stride=None, pad=(0,0), mode='max')\n\n\n\n\n\n\nws\n: scalar tuple. Factor by which to downsample the input\n\n\nignore_border\n: bool. When \nTrue\n, (5,5) input with \nws\n=(2,2) will generate a (2,2) output. (3,3) otherwise.\n\n\nstride\n: scalar tuple. The number of shifts over rows/cols to get the next pool region. If stride is None, it is considered equal to ws (no overlap on pooling regions), eg: \nstride\n=(1,1) will shifts over one row and one column for every iteration.\n\n\npad\n: pad zeros to extend beyond border of the input\n\n\nmode\n: {\nmax\n, \nsum\n, \naverage_inc_pad\n, \naverage_exc_pad\n}. Operation executed on each window. \nmax\n and \nsum\n always exclude the padding in the computation. \naverage\n gives you the choice to include or exclude it.\n\n\n\n\n\n\npool_3d\n\n\nPooling 3 dimension along the last 3 dimensions of input, support for any dimensional input with \nndim\n>=3.\n\n\npool_3d(x, ws=(2,2,2), ignore_border=True, stride=None, pad=(0,0,0), mode='max')\n\n\n\n\n\n\nws\n: scalar tuple. Factor by which to downsample the input\n\n\nignore_border\n: bool. When \nTrue\n, (5,5,5) input with \nws\n=(2,2,2) will generate a (2,2,2) output. (3,3,3) otherwise.\n\n\nstride\n: scalar tuple. The number of shifts over rows/cols to get the next pool region. If stride is None, it is considered equal to ws (no overlap on pooling regions).\n\n\npad\n: pad zeros to extend beyond border of the input\n\n\nmode\n: {\nmax\n, \nsum\n, \naverage_inc_pad\n, \naverage_exc_pad\n}. Operation executed on each window. \nmax\n and \nsum\n always exclude the padding in the computation. \naverage\n gives you the choice to include or exclude it.\n\n\n\n\n\n\nalign_crop\n\n\nAlign a list of tensors at each axis by specified rules and crop them to make axis concatenation possible.\n\n\nalign_crop(tensor_list, cropping)\n\n\n\n\n\n\ntensor_list\n: list of tensors to be processed, they much have the same \nndim\ns.\n\n\ncropping\n: list of cropping rules for each dimension. Acceptable rules include {\nNone\n|\nlower\n|\nupper\n|\ncenter\n}. \n\n\nNone\n: this axis is not cropped, tensors are unchanged in this axis\n\n\nlower\n: tensors are cropped choosing the lower portion in this axis as \na[:crop_size, ...]\n\n\nupper\n: tensors are cropped choosing the upper portion in this axis as \na[-crop_size:, ...]\n\n\ncenter\n: tensors are cropped choosing the central portion in this axis as \na[offset:offset+crop_size, ...]\n where \noffset = (a.shape[0]-crop_size)//2)\n\n\n\n\n\n\nspatial_pyramid_pooling\n\n\nSpatial pyramid pooling. This function will use different scale pooling pyramid to generate spatially fix-sized output no matter the spatial size of input, useful when CNN+FC used for image classification or detection with variable-sized samples.\n\n\nspatial_pyramid_pooling(x, pyramid_dims=(6, 4, 2, 1), mode='max')\n\n\n\n\n\n\nx\n: 4D tensor with shape (B, C, H, W)\n\n\npyramid_dims\n: list or tuple of integers. Refer to Ref[1] for details.\n\n\nmode\n: {\nmax\n, \nsum\n, \naverage_inc_pad\n, \naverage_exc_pad\n}. Operation executed on each window. \nmax\n and \nsum\n always exclude the padding in the computation. \naverage\n gives you the choice to include or exclude it.\n\n\n\n\nRef [1]: He, Kaiming et al (2015), Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition. \nhttp://arxiv.org/pdf/1406.4729.pdf\n\n\n\n\nupsample_2d\n\n\nUpsample 2 dimension along the last 2 dimensions of input, support for any dimensional input with \nndim\n>=2. Only integer upsampling ratio supported.\n\n\nupsample_2d(x, ratio, mode='repeat')\n\n\n\n\n\n\nratio\n: ust be integer or tuple of integers >=1\n\n\nmode\n: {\nrepeat\n, \ndilate\n}. Repeat element values or upsample leaving zeroes between upsampled elements. Default \nrepeat\n.\n\n\n\n\n\n\nupsample_2d_bilinear\n\n\nUpsample 2D with bilinear interpolation. Support for fractional ratio, and only apply for 4D tensor.\n\n\nupsample_2d_bilinear(x, ratio=None, frac_ratio=None, use_1D_kernel=True)\n\n\n\n\n\n\nratio\n: ust be integer or tuple of integers >=1. You can only specify either \nratio\n or \nfrac_ratio\n, not both.\n\n\nfrac_ratio\n: None, tuple of int or tuple of tuples of int. A fractional upsampling scale is described by (numerator, denominator).\n\n\nuse_1D_kernel\n: only for speed matter.\n\n\n\n\nNote: due to Theano's implementation, when the upsampling ratio is even, the last row and column is repeated one extra time compared to the first row and column which makes the upsampled tensor asymmetrical on both sides. This does not happen when the upsampling ratio is odd.",
            "title": "dandelion.functional"
        },
        {
            "location": "/dandelion_functional/#pool_1d",
            "text": "Pooling 1 dimension along the given axis, support for any dimensional input.  pool_1d(x, ws=2, ignore_border=True, stride=None, pad=0, mode='max', axis=-1)   ws : scalar int. Factor by which to downsample the input  ignore_border : bool. When  True , dimension size=5 with  ws =2 will generate a dimension size=2 output. 3 otherwise.  stride : scalar int. The number of shifts over rows/cols to get the next pool region. If stride is None, it is considered equal to ws (no overlap on pooling regions), eg:  stride =1 will shifts over one row for every iteration.  pad : pad zeros to extend beyond border of the input  mode : { max ,  sum ,  average_inc_pad ,  average_exc_pad }. Operation executed on each window.  max  and  sum  always exclude the padding in the computation.  average  gives you the choice to include or exclude it.  axis : scalar int. Specify along which axis the pooling will be done",
            "title": "pool_1d"
        },
        {
            "location": "/dandelion_functional/#pool_2d",
            "text": "Pooling 2 dimension along the last 2 dimensions of input, support for any dimensional input with  ndim >=2.  pool_2d(x, ws=(2,2), ignore_border=True, stride=None, pad=(0,0), mode='max')   ws : scalar tuple. Factor by which to downsample the input  ignore_border : bool. When  True , (5,5) input with  ws =(2,2) will generate a (2,2) output. (3,3) otherwise.  stride : scalar tuple. The number of shifts over rows/cols to get the next pool region. If stride is None, it is considered equal to ws (no overlap on pooling regions), eg:  stride =(1,1) will shifts over one row and one column for every iteration.  pad : pad zeros to extend beyond border of the input  mode : { max ,  sum ,  average_inc_pad ,  average_exc_pad }. Operation executed on each window.  max  and  sum  always exclude the padding in the computation.  average  gives you the choice to include or exclude it.",
            "title": "pool_2d"
        },
        {
            "location": "/dandelion_functional/#pool_3d",
            "text": "Pooling 3 dimension along the last 3 dimensions of input, support for any dimensional input with  ndim >=3.  pool_3d(x, ws=(2,2,2), ignore_border=True, stride=None, pad=(0,0,0), mode='max')   ws : scalar tuple. Factor by which to downsample the input  ignore_border : bool. When  True , (5,5,5) input with  ws =(2,2,2) will generate a (2,2,2) output. (3,3,3) otherwise.  stride : scalar tuple. The number of shifts over rows/cols to get the next pool region. If stride is None, it is considered equal to ws (no overlap on pooling regions).  pad : pad zeros to extend beyond border of the input  mode : { max ,  sum ,  average_inc_pad ,  average_exc_pad }. Operation executed on each window.  max  and  sum  always exclude the padding in the computation.  average  gives you the choice to include or exclude it.",
            "title": "pool_3d"
        },
        {
            "location": "/dandelion_functional/#align_crop",
            "text": "Align a list of tensors at each axis by specified rules and crop them to make axis concatenation possible.  align_crop(tensor_list, cropping)   tensor_list : list of tensors to be processed, they much have the same  ndim s.  cropping : list of cropping rules for each dimension. Acceptable rules include { None | lower | upper | center }.   None : this axis is not cropped, tensors are unchanged in this axis  lower : tensors are cropped choosing the lower portion in this axis as  a[:crop_size, ...]  upper : tensors are cropped choosing the upper portion in this axis as  a[-crop_size:, ...]  center : tensors are cropped choosing the central portion in this axis as  a[offset:offset+crop_size, ...]  where  offset = (a.shape[0]-crop_size)//2)",
            "title": "align_crop"
        },
        {
            "location": "/dandelion_functional/#spatial_pyramid_pooling",
            "text": "Spatial pyramid pooling. This function will use different scale pooling pyramid to generate spatially fix-sized output no matter the spatial size of input, useful when CNN+FC used for image classification or detection with variable-sized samples.  spatial_pyramid_pooling(x, pyramid_dims=(6, 4, 2, 1), mode='max')   x : 4D tensor with shape (B, C, H, W)  pyramid_dims : list or tuple of integers. Refer to Ref[1] for details.  mode : { max ,  sum ,  average_inc_pad ,  average_exc_pad }. Operation executed on each window.  max  and  sum  always exclude the padding in the computation.  average  gives you the choice to include or exclude it.   Ref [1]: He, Kaiming et al (2015), Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition.  http://arxiv.org/pdf/1406.4729.pdf",
            "title": "spatial_pyramid_pooling"
        },
        {
            "location": "/dandelion_functional/#upsample_2d",
            "text": "Upsample 2 dimension along the last 2 dimensions of input, support for any dimensional input with  ndim >=2. Only integer upsampling ratio supported.  upsample_2d(x, ratio, mode='repeat')   ratio : ust be integer or tuple of integers >=1  mode : { repeat ,  dilate }. Repeat element values or upsample leaving zeroes between upsampled elements. Default  repeat .",
            "title": "upsample_2d"
        },
        {
            "location": "/dandelion_functional/#upsample_2d_bilinear",
            "text": "Upsample 2D with bilinear interpolation. Support for fractional ratio, and only apply for 4D tensor.  upsample_2d_bilinear(x, ratio=None, frac_ratio=None, use_1D_kernel=True)   ratio : ust be integer or tuple of integers >=1. You can only specify either  ratio  or  frac_ratio , not both.  frac_ratio : None, tuple of int or tuple of tuples of int. A fractional upsampling scale is described by (numerator, denominator).  use_1D_kernel : only for speed matter.   Note: due to Theano's implementation, when the upsampling ratio is even, the last row and column is repeated one extra time compared to the first row and column which makes the upsampled tensor asymmetrical on both sides. This does not happen when the upsampling ratio is odd.",
            "title": "upsample_2d_bilinear"
        },
        {
            "location": "/dandelion_objective/",
            "text": "ctc_cost_logscale\n\n\nCTC cost calculated in \nlog\n scale. This CTC objective is written purely in Theano, so it runs on both Windows and Linux. Theano itself also has a \nwrapper\n for Baidu's \nwarp-ctc\n library, which requires separate install and only runs on Linux.\n\n\nctc_cost_logscale(seq, sm, seq_mask=None, sm_mask=None, blank_symbol=None, align='pre')\n\n\n\n\n\n\nseq\n: query sequence, shape of \n(L, B)\n, \nfloat32\n-typed\n\n\nsm\n: score matrix, shape of \n(T, C+1, B)\n, \nfloat32\n-typed\n\n\nseq_mask\n: mask for query sequence, shape of \n(L, B)\n, \nfloat32\n-typed\n\n\nsm_mask\n: mask for score matrix, shape of \n(T, B)\n, \nfloat32\n-typed\n\n\nblank_symbol\n: scalar, = \nC\n by default\n\n\nalign\n: string, {'pre'/'post'}, indicating how input samples are aligned in one batch\n\n\nreturn\n: negative log likelihood averaged over a batch\n\n\n\n\n\n\nctc_best_path_decode\n\n\nDecode the network output scorematrix by best-path-decoding scheme.\n\n\nctc_best_path_decode(Y, Y_mask=None, blank_symbol=None)\n\n\n\n\n\n\nY\n: output of a network, with shape \n(B, T, C+1)\n\n\nY_mask\n: mask of Y, with shape \n(B, T)\n\n\nreturn\n: result sequence of shape \n(T, B\n), and result sequence mask of shape \n(T, B)\n\n\n\n\n\n\nctc_CER\n\n\nCalculate the character error rate (CER) given ground truth \ntargetseq\n and CTC decoding output \nresultseq\n\n\nctc_CER(resultseq, targetseq, resultseq_mask=None, targetseq_mask=None)\n\n\n\n\n\n\nresultseq\n: CTC decoding output, with shape \n(T1, B)\n\n\ntargetseq\n: sequence ground truth, with shape \n(T2, B)\n\n\nreturn\n: tuple of \n(CER, TE, TG)\n, in which \nTE\n is the batch-wise total edit distance, \nTG\n is the batch-wise total ground truth sequence length, and \nCER\n equals to \nTE/TG\n\n\n\n\n\n\ncategorical_crossentropy\n\n\nComputes the categorical cross-entropy between predictions and targets\n\n\ncategorical_crossentropy(predictions, targets, eps=1e-7, m=None, class_weight=None)\n\n\n\n\n\n\npredictions\n: Theano 2D tensor, predictions in (0, 1), such as softmax output of a neural network, with data points in rows and class probabilities in columns.\n\n\ntargets\n: Theano 2D tensor or 1D tensor, either targets in [0, 1] (float32 type) matching the layout of \npredictions\n, or a vector of int giving the correct class index per data point. In the case of an integer vector argument, each element represents the position of the '1' in a one-hot encoding.\n\n\neps\n: epsilon added to \npredictions\n to prevent numerical unstability when using with softmax activation\n\n\nm\n: possible max value of \ntargets\n's element, required when \ntargets\n is 1D tensor and \nclass_weight\n is not None.\n\n\nclass_weight\n: tensor vector with shape (Nclass,), used for class weighting, optional.\n\n\nreturn\n: Theano 1D tensor, an expression for the item-wise categorical cross-entropy.\n\n\n\n\n\n\ncategorical_crossentropy_log\n\n\nComputes the categorical cross-entropy between predictions and targets, in log-domain.\n\n\ncategorical_crossentropy_log(log_predictions, targets, m=None, class_weight=None)\n\n\n\n\n\n\nlog_predictions\n: Theano 2D tensor, predictions in log of (0, 1), such as log_softmax output of a neural network, with data points in rows and class probabilities in columns.\n\n\ntargets\n: Theano 2D tensor or 1D tensor, either targets in [0, 1] (float32 type) matching the layout of \npredictions\n, or a vector of int giving the correct class index per data point. In the case of an integer vector argument, each element represents the position of the '1' in a one-hot encoding.\n\n\nm\n: possible max value of \ntargets\n's element, only used when \ntargets\n is 1D vector. When \ntargets\n is integer vector, the implementation of \ncategorical_crossentropy_log\n is different from \ncategorical_crossentropy\n: the latter relies on \ntheano.tensor.nnet.categorical_crossentropy\n whereas the former uses a simpler way, we transform the integer vector \ntargets\n into one-hot encoded matrix. That's why we need the \nm\n argument here. The possible limitation is that our implementation does not allow \nm\n changing on-the-fly.\n\n\nclass_weight\n: tensor vector with shape (Nclass,), used for class weighting, optional.\n\n\nreturn\n: Theano 1D tensor, an expression for the item-wise categorical cross-entropy in log-domain\n\n\n\n\n\n\nYou're recommended to refer to \nLasagne.objectives\n document\n for the following objectives:\n\n\n\n\nbinary_crossentropy\n\n\nsquared_error\n\n\nbinary_hinge_loss\n\n\nmulticlass_hinge_loss\n\n\nbinary_accuracy\n\n\ncategorical_accuracy",
            "title": "dandelion.objective"
        },
        {
            "location": "/dandelion_objective/#ctc_cost_logscale",
            "text": "CTC cost calculated in  log  scale. This CTC objective is written purely in Theano, so it runs on both Windows and Linux. Theano itself also has a  wrapper  for Baidu's  warp-ctc  library, which requires separate install and only runs on Linux.  ctc_cost_logscale(seq, sm, seq_mask=None, sm_mask=None, blank_symbol=None, align='pre')   seq : query sequence, shape of  (L, B) ,  float32 -typed  sm : score matrix, shape of  (T, C+1, B) ,  float32 -typed  seq_mask : mask for query sequence, shape of  (L, B) ,  float32 -typed  sm_mask : mask for score matrix, shape of  (T, B) ,  float32 -typed  blank_symbol : scalar, =  C  by default  align : string, {'pre'/'post'}, indicating how input samples are aligned in one batch  return : negative log likelihood averaged over a batch",
            "title": "ctc_cost_logscale"
        },
        {
            "location": "/dandelion_objective/#ctc_best_path_decode",
            "text": "Decode the network output scorematrix by best-path-decoding scheme.  ctc_best_path_decode(Y, Y_mask=None, blank_symbol=None)   Y : output of a network, with shape  (B, T, C+1)  Y_mask : mask of Y, with shape  (B, T)  return : result sequence of shape  (T, B ), and result sequence mask of shape  (T, B)",
            "title": "ctc_best_path_decode"
        },
        {
            "location": "/dandelion_objective/#ctc_cer",
            "text": "Calculate the character error rate (CER) given ground truth  targetseq  and CTC decoding output  resultseq  ctc_CER(resultseq, targetseq, resultseq_mask=None, targetseq_mask=None)   resultseq : CTC decoding output, with shape  (T1, B)  targetseq : sequence ground truth, with shape  (T2, B)  return : tuple of  (CER, TE, TG) , in which  TE  is the batch-wise total edit distance,  TG  is the batch-wise total ground truth sequence length, and  CER  equals to  TE/TG",
            "title": "ctc_CER"
        },
        {
            "location": "/dandelion_objective/#categorical_crossentropy",
            "text": "Computes the categorical cross-entropy between predictions and targets  categorical_crossentropy(predictions, targets, eps=1e-7, m=None, class_weight=None)   predictions : Theano 2D tensor, predictions in (0, 1), such as softmax output of a neural network, with data points in rows and class probabilities in columns.  targets : Theano 2D tensor or 1D tensor, either targets in [0, 1] (float32 type) matching the layout of  predictions , or a vector of int giving the correct class index per data point. In the case of an integer vector argument, each element represents the position of the '1' in a one-hot encoding.  eps : epsilon added to  predictions  to prevent numerical unstability when using with softmax activation  m : possible max value of  targets 's element, required when  targets  is 1D tensor and  class_weight  is not None.  class_weight : tensor vector with shape (Nclass,), used for class weighting, optional.  return : Theano 1D tensor, an expression for the item-wise categorical cross-entropy.",
            "title": "categorical_crossentropy"
        },
        {
            "location": "/dandelion_objective/#categorical_crossentropy_log",
            "text": "Computes the categorical cross-entropy between predictions and targets, in log-domain.  categorical_crossentropy_log(log_predictions, targets, m=None, class_weight=None)   log_predictions : Theano 2D tensor, predictions in log of (0, 1), such as log_softmax output of a neural network, with data points in rows and class probabilities in columns.  targets : Theano 2D tensor or 1D tensor, either targets in [0, 1] (float32 type) matching the layout of  predictions , or a vector of int giving the correct class index per data point. In the case of an integer vector argument, each element represents the position of the '1' in a one-hot encoding.  m : possible max value of  targets 's element, only used when  targets  is 1D vector. When  targets  is integer vector, the implementation of  categorical_crossentropy_log  is different from  categorical_crossentropy : the latter relies on  theano.tensor.nnet.categorical_crossentropy  whereas the former uses a simpler way, we transform the integer vector  targets  into one-hot encoded matrix. That's why we need the  m  argument here. The possible limitation is that our implementation does not allow  m  changing on-the-fly.  class_weight : tensor vector with shape (Nclass,), used for class weighting, optional.  return : Theano 1D tensor, an expression for the item-wise categorical cross-entropy in log-domain    You're recommended to refer to  Lasagne.objectives  document  for the following objectives:   binary_crossentropy  squared_error  binary_hinge_loss  multiclass_hinge_loss  binary_accuracy  categorical_accuracy",
            "title": "categorical_crossentropy_log"
        },
        {
            "location": "/dandelion_activation/",
            "text": "Dandelion's \nactivation\n module is mostly inherited from \nLasagne\n except for the \nsoftmax()\n and \nlog_softmax()\n activations. \n\n\nYou're recommended to refer to \nLasagne.nonlinearities\n document\n for the following activations:\n\n\n\n\nsigmoid\n\n\ntanh\n\n\nrelu\n\n\nsoftplus\n\n\nultra_fast_sigmoid\n\n\nScaledTanH\n\n\nleaky_rectify\n\n\nvery_leaky_rectify\n\n\nelu\n\n\nSELU\n\n\nlinear\n\n\nidentity\n\n\n\n\n\n\nsoftmax\n\n\nApply softmax to the last dimension of input \nx\n\n\nsoftmax(x)\n\n\n\n\n\n\nx\n: theano tensor of any shape\n\n\n\n\n\n\nlog_softmax\n\n\nApply softmax to the last dimension of input \nx\n, in log domain\n\n\nlog_softmax(x)\n\n\n\n\n\n\nx\n: theano tensor of any shape",
            "title": "dandelion.activation"
        },
        {
            "location": "/dandelion_activation/#softmax",
            "text": "Apply softmax to the last dimension of input  x  softmax(x)   x : theano tensor of any shape",
            "title": "softmax"
        },
        {
            "location": "/dandelion_activation/#log_softmax",
            "text": "Apply softmax to the last dimension of input  x , in log domain  log_softmax(x)   x : theano tensor of any shape",
            "title": "log_softmax"
        },
        {
            "location": "/dandelion_update/",
            "text": "Dandelion's \nupdate\n module is mostly inherited from \nLasagne\n, you're recommended to refer to \nLasagne.updates\n document\n for details.",
            "title": "dandelion.update"
        },
        {
            "location": "/dandelion_initialization/",
            "text": "Dandelion's \ninitialization\n module is mostly inherited from \nLasagne\n.\nYou're recommended to refer to \nLasagne.init\n document\n for the details.",
            "title": "dandelion.initialization"
        },
        {
            "location": "/dandelion_model/",
            "text": "U-net FCN\n\n\nReference implementation of \nU-net\n FCN\n\n\nclass model_Unet(channel=1, im_height=128, im_width=128, Nclass=2, kernel_size=3, \n                 border_mode='same', base_n_filters=64, output_activation=softmax)\n\n\n\n\n\n\nchannel\n: input channel number\n\n\nNclass\n: output channel number\n\n\n\n\nThe model accepts input of shape in the order of (B, C, H, W), and outputs with shape in the order of (B, H, W, C).\n\n\n\n\nVGG-16 network\n\n\nReference implementation of \nVGG-16\n network\n\n\nclass model_VGG16(channel=3, im_height=224, im_width=224, Nclass=1000, \n                  kernel_size=3, border_mode=(1, 1), flip_filters=False)\n\n\n\n\n\n\nchannel\n: input channel number\n\n\nNclass\n: output class number\n\n\n\n\nThe model accepts input of shape in the order of (B, C, H, W), and outputs with shape (B, N).\n\n\n\n\nResNet bottleneck\n\n\nReference implementation of bottleneck building block of \nResNet\n network\n\n\nclass ResNet_bottleneck(outer_channel=256, inner_channel=64, border_mode='same',\n                        batchnorm_mode=1, activation=relu)\n\n\n\n\n\n\nouter_channel\n: channel number of block input\n\n\ninner_channel\n: channel number inside the block\n\n\nbatchnorm_mode\n: {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn\n\n\nactivation\n: default = relu. \nNote no activation applied to the last element-wise sum output.\n\n\n\n\nThe model accepts input of shape in the order of (B, C, H, W), and outputs with the same shape.\n\n\n\n\nFeature Pyramid Network\n\n\nReference implementation of \nfeature pyramid network\n\n\nclass model_FPN(input_channel=3, base_n_filters=64, batchnorm_mode=1)\n\n\n\n\n\n\nbatchnorm_mode\n: same with \nResNet_bottleneck\n\n\nreturn\n 4-element tuple \n(p2, p3, p4, p5)\n,  CNN pyramid features at different scales, each with #channel = 4 * \nbase_n_filters\n\n\n\n\n\n\nDepthwise Separable Convolution\n\n\nReference implementation of \nDepthwise Separable Convolution\n\n\nclass DSConv2D(in_channels, out_channels, kernel_size=(3,3), stride=(1,1), \n               dilation=(1,1), pad='valid')\n\n\n\n\n\n\ninput_channels\n: int. Input shape is (B, input_channels, H_in, W_in)\n\n\nout_channels\n: int. Output shape is (B output_channels, H_out, W_out)\n\n\nkernel_size\n: int scalar or tuple of int. Convolution kernel size\n\n\nstride\n: Factor by which to subsample the output\n\n\npad\n: \nsame\n/\nvalid\n/\nfull\n or 2-element tuple of int. Control image border padding.\n\n\ndilation\n: factor by which to subsample (stride) the input.\n\n\n\n\nThe model do the depthwise 2D convolution per-channel of input, then map the output to #out_channels number of channel by pointwise 1*1 convolution. No activation applied inside.\n\n\n\n\nShuffleUnit\n\n\nReference implementation of \nshuffle-net\n unit\n\n\nclass ShuffleUnit(in_channels=256, inner_channels=None, out_channels=None, group_num=4, border_mode='same', \n                  batchnorm_mode=1, activation=relu, stride=(1,1), dilation=(1,1), fusion_mode='add')\n\n\n\n\n\n\nin_channels\n: channel number of unit input\n\n\ninner_channel\n: optional, channel number inside the unit, default = \nin_channels//4\n\n\nout_channels\n: channel number of unit output, only used when \nfusion_mode\n = 'concat', and must > \nin_channels\n\n\ngroup_num\n: number of convolution groups\n\n\nborder_mode\n: only \nsame\n allowed\n\n\nbatchnorm_mode\n: {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn\n\n\nactivation\n: default = relu. \nNote no activation applied to the last output.\n\n\nstride, dilation\n: only used for depthwise separable convolution module inside\n\n\nfusion_mode\n: {'add' | 'concat'}.\n\n\nreturn\n: convolution result with #channel = \nin_channels\n when \nfusion_mode\n='add', #channel = \nout_channels\n when \nfusion_mode\n='concat'\n\n\n\n\nShuffleUnit_Stack\n\n\nReference implementation of shuffle-net unit stack\n\n\nclass ShuffleUnit_Stack(in_channels, inner_channels=None, out_channels=None, group_num=4, batchnorm_mode=1, \n                        activation=relu, stack_size=3)\n\n\n\n\n\n\nin_channels\n: channel number of input\n\n\ninner_channel\n: optional, channel number inside the shuffle-unit, default = \nin_channels//4\n\n\nout_channels\n: channel number of stack output, must > \nin_channels\n\n\ngroup_num\n: number of convolution groups\n\n\nbatchnorm_mode\n: {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn\n\n\nactivation\n: default = relu. \nNote no activation applied to the last output.\n\n\nstack_size\n: number of shuffle-unit in the stack\n\n\n\n\nShuffleNet\n\n\nReference implementation of \nshuffle-net\n, without the final Dense layer.\n\n\nclass model_ShuffleNet(in_channels, group_num=4, stage_channels=(24, 272, 544, 1088), stack_size=(3, 7, 3), \n                       batchnorm_mode=1, activation=relu)\n\n\n\n\n\n\nin_channels\n: channel number of input\n\n\ngroup_num\n: number of convolution groups\n\n\nstage_channels\n: channel number of each stage output.\n\n\nstack_size\n: size of each stack.\n\n\nbatchnorm_mode\n: {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn\n\n\nactivation\n: default = relu. \nNote no activation applied to the last output.\n\n\n\n\n\n\nShuffle-Seg network\n\n\nModel reference implementation of \nShuffleSeg\n\n\nclass model_ShuffleSeg(in_channels=1, Nclass=6, SF_group_num=4, SF_stage_channels=(24, 272, 544, 1088), \n                       SF_stack_size=(3, 7, 3), SF_batchnorm_mode=1, SF_activation=relu)\n\n\n\n\n\n\nin_channels\n: channel number of input\n\n\nNclass\n: output class number\n\n\nSF_group_num\n: number of convolution groups for inside ShuffleNet encoder.\n\n\nSF_stage_channels\n: channel number of each stage output for inside ShuffleNet encoder.\n\n\nSF_stack_size\n: size of each stack for inside ShuffleNet encoder.\n\n\nSF_batchnorm_mode\n: {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn. For inside ShuffleNet encoder\n\n\nSF_activation\n: default = relu. For inside ShuffleNet encoder.",
            "title": "dandelion.model"
        },
        {
            "location": "/dandelion_model/#u-net-fcn",
            "text": "Reference implementation of  U-net  FCN  class model_Unet(channel=1, im_height=128, im_width=128, Nclass=2, kernel_size=3, \n                 border_mode='same', base_n_filters=64, output_activation=softmax)   channel : input channel number  Nclass : output channel number   The model accepts input of shape in the order of (B, C, H, W), and outputs with shape in the order of (B, H, W, C).",
            "title": "U-net FCN"
        },
        {
            "location": "/dandelion_model/#vgg-16-network",
            "text": "Reference implementation of  VGG-16  network  class model_VGG16(channel=3, im_height=224, im_width=224, Nclass=1000, \n                  kernel_size=3, border_mode=(1, 1), flip_filters=False)   channel : input channel number  Nclass : output class number   The model accepts input of shape in the order of (B, C, H, W), and outputs with shape (B, N).",
            "title": "VGG-16 network"
        },
        {
            "location": "/dandelion_model/#resnet-bottleneck",
            "text": "Reference implementation of bottleneck building block of  ResNet  network  class ResNet_bottleneck(outer_channel=256, inner_channel=64, border_mode='same',\n                        batchnorm_mode=1, activation=relu)   outer_channel : channel number of block input  inner_channel : channel number inside the block  batchnorm_mode : {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn  activation : default = relu.  Note no activation applied to the last element-wise sum output.   The model accepts input of shape in the order of (B, C, H, W), and outputs with the same shape.",
            "title": "ResNet bottleneck"
        },
        {
            "location": "/dandelion_model/#feature-pyramid-network",
            "text": "Reference implementation of  feature pyramid network  class model_FPN(input_channel=3, base_n_filters=64, batchnorm_mode=1)   batchnorm_mode : same with  ResNet_bottleneck  return  4-element tuple  (p2, p3, p4, p5) ,  CNN pyramid features at different scales, each with #channel = 4 *  base_n_filters",
            "title": "Feature Pyramid Network"
        },
        {
            "location": "/dandelion_model/#depthwise-separable-convolution",
            "text": "Reference implementation of  Depthwise Separable Convolution  class DSConv2D(in_channels, out_channels, kernel_size=(3,3), stride=(1,1), \n               dilation=(1,1), pad='valid')   input_channels : int. Input shape is (B, input_channels, H_in, W_in)  out_channels : int. Output shape is (B output_channels, H_out, W_out)  kernel_size : int scalar or tuple of int. Convolution kernel size  stride : Factor by which to subsample the output  pad :  same / valid / full  or 2-element tuple of int. Control image border padding.  dilation : factor by which to subsample (stride) the input.   The model do the depthwise 2D convolution per-channel of input, then map the output to #out_channels number of channel by pointwise 1*1 convolution. No activation applied inside.",
            "title": "Depthwise Separable Convolution"
        },
        {
            "location": "/dandelion_model/#shuffleunit",
            "text": "Reference implementation of  shuffle-net  unit  class ShuffleUnit(in_channels=256, inner_channels=None, out_channels=None, group_num=4, border_mode='same', \n                  batchnorm_mode=1, activation=relu, stride=(1,1), dilation=(1,1), fusion_mode='add')   in_channels : channel number of unit input  inner_channel : optional, channel number inside the unit, default =  in_channels//4  out_channels : channel number of unit output, only used when  fusion_mode  = 'concat', and must >  in_channels  group_num : number of convolution groups  border_mode : only  same  allowed  batchnorm_mode : {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn  activation : default = relu.  Note no activation applied to the last output.  stride, dilation : only used for depthwise separable convolution module inside  fusion_mode : {'add' | 'concat'}.  return : convolution result with #channel =  in_channels  when  fusion_mode ='add', #channel =  out_channels  when  fusion_mode ='concat'",
            "title": "ShuffleUnit"
        },
        {
            "location": "/dandelion_model/#shuffleunit_stack",
            "text": "Reference implementation of shuffle-net unit stack  class ShuffleUnit_Stack(in_channels, inner_channels=None, out_channels=None, group_num=4, batchnorm_mode=1, \n                        activation=relu, stack_size=3)   in_channels : channel number of input  inner_channel : optional, channel number inside the shuffle-unit, default =  in_channels//4  out_channels : channel number of stack output, must >  in_channels  group_num : number of convolution groups  batchnorm_mode : {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn  activation : default = relu.  Note no activation applied to the last output.  stack_size : number of shuffle-unit in the stack",
            "title": "ShuffleUnit_Stack"
        },
        {
            "location": "/dandelion_model/#shufflenet",
            "text": "Reference implementation of  shuffle-net , without the final Dense layer.  class model_ShuffleNet(in_channels, group_num=4, stage_channels=(24, 272, 544, 1088), stack_size=(3, 7, 3), \n                       batchnorm_mode=1, activation=relu)   in_channels : channel number of input  group_num : number of convolution groups  stage_channels : channel number of each stage output.  stack_size : size of each stack.  batchnorm_mode : {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn  activation : default = relu.  Note no activation applied to the last output.",
            "title": "ShuffleNet"
        },
        {
            "location": "/dandelion_model/#shuffle-seg-network",
            "text": "Model reference implementation of  ShuffleSeg  class model_ShuffleSeg(in_channels=1, Nclass=6, SF_group_num=4, SF_stage_channels=(24, 272, 544, 1088), \n                       SF_stack_size=(3, 7, 3), SF_batchnorm_mode=1, SF_activation=relu)   in_channels : channel number of input  Nclass : output class number  SF_group_num : number of convolution groups for inside ShuffleNet encoder.  SF_stage_channels : channel number of each stage output for inside ShuffleNet encoder.  SF_stack_size : size of each stack for inside ShuffleNet encoder.  SF_batchnorm_mode : {0 | 1 | 2}. 0 means no batch normalization applied; 1 means batch normalization applied to each cnn; 2 means batch normalization only applied to the last cnn. For inside ShuffleNet encoder  SF_activation : default = relu. For inside ShuffleNet encoder.",
            "title": "Shuffle-Seg network"
        },
        {
            "location": "/dandelion_ext_CV/",
            "text": "imread\n\n\nRead image file and return as numpy \nndarray\n, using PILLOW as backend. Support for EXIF rotation specification.\n\n\nimread(f, flatten=False, dtype='float32')\n\n\n\n\n\n\nf\n: str or file object. The file name or file object to be read from.\n\n\nflatten\n: bool. If \nTrue\n, flattens the color channels into a single gray-scale channel.\n\n\ndtype\n: returned data type\n\n\n\n\n\n\nimsave\n\n\nSave an image \nndarray\n into file, using PILLOW as backend \n\n\nimsave(f, I, **params)\n\n\n\n\n\n\nf\n: str or file object. The file name or file object to be written into.\n\n\nI\n: Image \nndarray\n. Note for \njpeg\n format, \nI\n should be of \nuint8\n type.\n\n\nparams\n: other parameters passed directly to PILLOW's \nimage.save()",
            "title": "dandelion.ext.CV"
        },
        {
            "location": "/dandelion_ext_CV/#imread",
            "text": "Read image file and return as numpy  ndarray , using PILLOW as backend. Support for EXIF rotation specification.  imread(f, flatten=False, dtype='float32')   f : str or file object. The file name or file object to be read from.  flatten : bool. If  True , flattens the color channels into a single gray-scale channel.  dtype : returned data type",
            "title": "imread"
        },
        {
            "location": "/dandelion_ext_CV/#imsave",
            "text": "Save an image  ndarray  into file, using PILLOW as backend   imsave(f, I, **params)   f : str or file object. The file name or file object to be written into.  I : Image  ndarray . Note for  jpeg  format,  I  should be of  uint8  type.  params : other parameters passed directly to PILLOW's  image.save()",
            "title": "imsave"
        },
        {
            "location": "/history/",
            "text": "History\n\n\nversion 0.17.7 [8-2-2018]\n\n\nFrom this version the documentaiton supports latex math officially.\n\n* \nMODIFIED\n: move arg \nalpha\n of \nModule.Center\n from class delcaration to its \n.forward()\n interface.\n\n\nversion 0.17.6 [7-25-2018]\n\n\n\n\nMODIFIED\n: change default value of \nModule.set_weights_by_name()\n's arg \nunmatched\n from \nignore\n to \nraise\n\n\nMODIFIED\n: change default value of \nmodel.vgg.model_VGG16()\n's arg \nflip_filters\n from \nTrue\n to \nFalse\n\n\n\n\nversion 0.17.5 [7-20-2018]\n\n\n\n\nFIXED\n: fixed typo in \nobjective::categorical_crossentropy()\n\n\n\n\nversion 0.17.4 [7-20-2018]\n\n\n\n\nNEW\n: add class weighting support for \nobjective::categorical_crossentropy()\n and \nobjective::categorical_crossentropy_log()\n\n\nNEW\n: add \nutil::theano_safe_run()\n to help catch memory exceptions when running theano functions.\n\n\n\n\nversion 0.17.3 [7-18-2018]\n\n\n\n\nFIXED\n: pooling mode in \nmodel::shufflenet::ShuffleUnit\n changed to \naverage_inc_pad\n for correct gradient.\n\n\n\n\nversion 0.17.2 [7-17-2018]\n\n\n\n\nNEW\n: add \nmodel::shufflenet::model_ShuffleSeg\n for Shuffle-Seg model reference implementation.\n\n\n\n\nversion 0.17.1 [7-12-2018]\n\n\n\n\nMODIFIED\n: modify all \nTest/Test_*.py\n to be compatible with pytest. \n\n\nNEW\n: add Travis CI for automatic unit test.\n\n\n\n\nversion 0.17.0 [7-12-2018]\n\n\nIn this version the \nModule\n's parameter and sub-module naming conventions are changed to make sure unique name for each variable/module in a complex network.\n\nIt's \nincompatible\n with previous version if your work accessed their names, otherwise there is no impact.\n\nNote: to set weights saved by previous dandelion(>=version 0.14.0), use \n.set_weights()\n instead of \n.set_weights_by_name()\n. For weights saved by dandelion of version < 0.14.0, the quick way is to set the model's submodule weight explicitly as \nmodel_new_dandelion.conv1.W.set_value(model_old_dandelion.conv1.W.get_value())\n.  \n\nFrom this version, it's recommonded to let the framework auto-name the module parameters when you define your own module with \nregister_param()\n and \nregister_self_updating_variable()\n.\n\n\n\n\nMODIFIED\n: module's variable name convention changed to \nvariable_name@parent_module_name\n to make sure unique name for each variable in a complex network\n\n\nMODIFIED\n: module's name convention changed to \nclass_name|instance_name@parent_module_name\n to make sure unique name for each module in a complex network\n\n\nMODIFIED\n: remove all specified names for \nregister_param()\n and \nregister_self_updating_variable()\n. Leave the variables to be named automatically by their parent module.\n\n\nMODIFIED\n: improve \nmodel::shufflenet::ShuffleUnit\n.\n\n\nNEW\n: add \nSequential\n container in \ndandelion.module\n for usage convenience.\n\n\nNEW\n: add \nmodel::shufflenet::ShuffleUnit_Stack\n and \nmodel::shufflenet::ShuffleNet\n for ShuffleNet reference implementation.\n\n\n\n\nversion 0.16.10 [7-10-2018]\n\n\n\n\nMODIFIED\n: disable all install requirements to prevent possible conflict of pip and conda channel.\n\n\n\n\nversion 0.16.9 [7-10-2018]\n\n\n\n\nMODIFIED\n: import all model reference implementations into \ndandelion.model\n's namespace\n\n\nFIXED\n: \nConvTransposed2D\n's \nW_shape\n should use \nin_channels\n as first dimension; incorrect \nW_shape\n when \nnum_groups\n > 1.\n\n\n\n\nversion 0.16.8 [7-9-2018]\n\n\n\n\nNEW\n: add \nmodel::shufflenet::DSConv2D\n for Depthwise Separable Convolution reference implementation.\n\n\nNEW\n: add \nmodel::shufflenet::ShuffleUnit\n for ShuffleNet reference implementation\n\n\nFIXED\n: \nW_shape\n of \nmodule::Conv2D\n should count for \nnum_groups\n\n\n\n\nversion 0.16.7 [7-6-2018]\n\n\n\n\nNEW\n: add \nmodel::vgg::model_VGG16\n for VGG-16 reference implementation.\n\n\nNEW\n: add \nmodel::resnet::ResNet_bottleneck\n for ResNet reference implementation\n\n\nNEW\n: add \nmodel::feature_pyramid_net::model_FPN\n for Feature Pyramid Network reference implementation\n\n\n\n\nversion 0.16.6 [7-5-2018]\n\n\n\n\nNEW\n: add \nfunctional::upsample_2d()\n for 2D upsampling\n\n\nNEW\n: add \nfunctional::upsample_2d_bilinear()\nfor bilinear 2D upsampling\n\n\n\n\nversion 0.16.5 [7-5-2018]\n\n\n\n\nNEW\n: add \nfunctional::spatial_pyramid_pooling()\n for SPP-net implementation.\n\n\n\n\nversion 0.16.4 [7-4-2018]\n\n\n\n\nFIXED\n: wrong indexing when \ntargets\n is int vector for \nobjective::categorical_crossentropy_log()\n.\n\n\n\n\nversion 0.16.3 [7-3-2018]\n\n\n\n\nNEW\n: add \nactivation::log_softmax()\n for more numerically stable softmax.\n\n\nNEW\n: add \nobjective::categorical_crossentropy_log()\n for more numerically stable categorical cross-entropy\n\n\nMODIFIED\n: add \neps\n argument to \nobjective::categorical_crossentropy()\n for numerical stability purpose. Note 1e-7 is set as default value of \neps\n. You can set it to 0 to get the old \ncategorical_crossentropy()\n back.\n\n\n\n\nversion 0.16.0 [6-13-2018]\n\n\n\n\nNEW\n: add \next\n module into master branch of Dandelion. All the miscellaneous extensions will be organized in here.\n\n\nNEW\n: add \next.CV\n sub-module, containing image I/O functions and basic image processing functions commonly used in model training.\n\n\n\n\nversion 0.15.2 [5-28-2018]\n\n\n\n\nFIXED\n: \nconvTOP\n should be constructed each time the \nforward()\n function of \nConvTransposed2D\n is called.\n\n\n\n\nversion 0.15.1 [5-25-2018]\n\n\n\n\nNEW\n: add \nmodel\n module into master branch of Dandelion\n\n\nNEW\n: add U-net FCN implementation into \nmodel\n module\n\n\nNEW\n: add \nalign_crop()\n into \nfunctional\n module\n\n\n\n\nversion 0.14.4 [4-17-2018]\n\n\nRename \nupdates.py\n with \nupdate.py\n\n\nversion 0.14.0 [4-10-2018]\n\n\nIn this version the \nModule\n's parameter interfaces are mostly redesigned, so it's \nincompatible\n with previous version.\nNow \nself.params\n and \nself.self_updating_variables\n do not include sub-modules' parameters any more, to get all the parameters to be\ntrained by optimizer, including sub-modules' during training, you'll need to call the new interface function  \n.collect_params()\n. \nTo collect self-defined updates for training, still call \n.collect_self_updates()\n.\n\n\n\n\nMODIFIED\n: \n.get_weights()\n and \n.set_weights()\n traverse the parameters in the same order of sub-modules, so they're \nincompatible\n with previous version.\n\n\nMODIFIED\n: Rewind all \ntrainable\n flags, you're now expected to use the \ninclude\n and \nexclude\n arguments in \n.collect_params()\n and \n\n.collect_self_updates()\n to enable/disable training for certain module's parameters.\n\n\nMODIFIED\n: to define self-update expression for \nself_updating_variable\n, use \n.update\n attribute instead of previous \n.default_update\n\n\nNEW\n: add auto-naming feature to root class \nModule\n: if a sub-module is unnamed yet, it'll be auto-named by its instance name, \nfrom now on you don't need to name a sub-module manually any more.\n\n\nNEW\n: add \n.set_weights_by_name()\n to \nModule\n class, you can use this function to set module weights saved by previous version of Dandelion",
            "title": "History"
        },
        {
            "location": "/history/#history",
            "text": "",
            "title": "History"
        },
        {
            "location": "/history/#version-0177-8-2-2018",
            "text": "From this version the documentaiton supports latex math officially. \n*  MODIFIED : move arg  alpha  of  Module.Center  from class delcaration to its  .forward()  interface.",
            "title": "version 0.17.7 [8-2-2018]"
        },
        {
            "location": "/history/#version-0176-7-25-2018",
            "text": "MODIFIED : change default value of  Module.set_weights_by_name() 's arg  unmatched  from  ignore  to  raise  MODIFIED : change default value of  model.vgg.model_VGG16() 's arg  flip_filters  from  True  to  False",
            "title": "version 0.17.6 [7-25-2018]"
        },
        {
            "location": "/history/#version-0175-7-20-2018",
            "text": "FIXED : fixed typo in  objective::categorical_crossentropy()",
            "title": "version 0.17.5 [7-20-2018]"
        },
        {
            "location": "/history/#version-0174-7-20-2018",
            "text": "NEW : add class weighting support for  objective::categorical_crossentropy()  and  objective::categorical_crossentropy_log()  NEW : add  util::theano_safe_run()  to help catch memory exceptions when running theano functions.",
            "title": "version 0.17.4 [7-20-2018]"
        },
        {
            "location": "/history/#version-0173-7-18-2018",
            "text": "FIXED : pooling mode in  model::shufflenet::ShuffleUnit  changed to  average_inc_pad  for correct gradient.",
            "title": "version 0.17.3 [7-18-2018]"
        },
        {
            "location": "/history/#version-0172-7-17-2018",
            "text": "NEW : add  model::shufflenet::model_ShuffleSeg  for Shuffle-Seg model reference implementation.",
            "title": "version 0.17.2 [7-17-2018]"
        },
        {
            "location": "/history/#version-0171-7-12-2018",
            "text": "MODIFIED : modify all  Test/Test_*.py  to be compatible with pytest.   NEW : add Travis CI for automatic unit test.",
            "title": "version 0.17.1 [7-12-2018]"
        },
        {
            "location": "/history/#version-0170-7-12-2018",
            "text": "In this version the  Module 's parameter and sub-module naming conventions are changed to make sure unique name for each variable/module in a complex network. \nIt's  incompatible  with previous version if your work accessed their names, otherwise there is no impact. \nNote: to set weights saved by previous dandelion(>=version 0.14.0), use  .set_weights()  instead of  .set_weights_by_name() . For weights saved by dandelion of version < 0.14.0, the quick way is to set the model's submodule weight explicitly as  model_new_dandelion.conv1.W.set_value(model_old_dandelion.conv1.W.get_value()) .   \nFrom this version, it's recommonded to let the framework auto-name the module parameters when you define your own module with  register_param()  and  register_self_updating_variable() .   MODIFIED : module's variable name convention changed to  variable_name@parent_module_name  to make sure unique name for each variable in a complex network  MODIFIED : module's name convention changed to  class_name|instance_name@parent_module_name  to make sure unique name for each module in a complex network  MODIFIED : remove all specified names for  register_param()  and  register_self_updating_variable() . Leave the variables to be named automatically by their parent module.  MODIFIED : improve  model::shufflenet::ShuffleUnit .  NEW : add  Sequential  container in  dandelion.module  for usage convenience.  NEW : add  model::shufflenet::ShuffleUnit_Stack  and  model::shufflenet::ShuffleNet  for ShuffleNet reference implementation.",
            "title": "version 0.17.0 [7-12-2018]"
        },
        {
            "location": "/history/#version-01610-7-10-2018",
            "text": "MODIFIED : disable all install requirements to prevent possible conflict of pip and conda channel.",
            "title": "version 0.16.10 [7-10-2018]"
        },
        {
            "location": "/history/#version-0169-7-10-2018",
            "text": "MODIFIED : import all model reference implementations into  dandelion.model 's namespace  FIXED :  ConvTransposed2D 's  W_shape  should use  in_channels  as first dimension; incorrect  W_shape  when  num_groups  > 1.",
            "title": "version 0.16.9 [7-10-2018]"
        },
        {
            "location": "/history/#version-0168-7-9-2018",
            "text": "NEW : add  model::shufflenet::DSConv2D  for Depthwise Separable Convolution reference implementation.  NEW : add  model::shufflenet::ShuffleUnit  for ShuffleNet reference implementation  FIXED :  W_shape  of  module::Conv2D  should count for  num_groups",
            "title": "version 0.16.8 [7-9-2018]"
        },
        {
            "location": "/history/#version-0167-7-6-2018",
            "text": "NEW : add  model::vgg::model_VGG16  for VGG-16 reference implementation.  NEW : add  model::resnet::ResNet_bottleneck  for ResNet reference implementation  NEW : add  model::feature_pyramid_net::model_FPN  for Feature Pyramid Network reference implementation",
            "title": "version 0.16.7 [7-6-2018]"
        },
        {
            "location": "/history/#version-0166-7-5-2018",
            "text": "NEW : add  functional::upsample_2d()  for 2D upsampling  NEW : add  functional::upsample_2d_bilinear() for bilinear 2D upsampling",
            "title": "version 0.16.6 [7-5-2018]"
        },
        {
            "location": "/history/#version-0165-7-5-2018",
            "text": "NEW : add  functional::spatial_pyramid_pooling()  for SPP-net implementation.",
            "title": "version 0.16.5 [7-5-2018]"
        },
        {
            "location": "/history/#version-0164-7-4-2018",
            "text": "FIXED : wrong indexing when  targets  is int vector for  objective::categorical_crossentropy_log() .",
            "title": "version 0.16.4 [7-4-2018]"
        },
        {
            "location": "/history/#version-0163-7-3-2018",
            "text": "NEW : add  activation::log_softmax()  for more numerically stable softmax.  NEW : add  objective::categorical_crossentropy_log()  for more numerically stable categorical cross-entropy  MODIFIED : add  eps  argument to  objective::categorical_crossentropy()  for numerical stability purpose. Note 1e-7 is set as default value of  eps . You can set it to 0 to get the old  categorical_crossentropy()  back.",
            "title": "version 0.16.3 [7-3-2018]"
        },
        {
            "location": "/history/#version-0160-6-13-2018",
            "text": "NEW : add  ext  module into master branch of Dandelion. All the miscellaneous extensions will be organized in here.  NEW : add  ext.CV  sub-module, containing image I/O functions and basic image processing functions commonly used in model training.",
            "title": "version 0.16.0 [6-13-2018]"
        },
        {
            "location": "/history/#version-0152-5-28-2018",
            "text": "FIXED :  convTOP  should be constructed each time the  forward()  function of  ConvTransposed2D  is called.",
            "title": "version 0.15.2 [5-28-2018]"
        },
        {
            "location": "/history/#version-0151-5-25-2018",
            "text": "NEW : add  model  module into master branch of Dandelion  NEW : add U-net FCN implementation into  model  module  NEW : add  align_crop()  into  functional  module",
            "title": "version 0.15.1 [5-25-2018]"
        },
        {
            "location": "/history/#version-0144-4-17-2018",
            "text": "Rename  updates.py  with  update.py",
            "title": "version 0.14.4 [4-17-2018]"
        },
        {
            "location": "/history/#version-0140-4-10-2018",
            "text": "In this version the  Module 's parameter interfaces are mostly redesigned, so it's  incompatible  with previous version.\nNow  self.params  and  self.self_updating_variables  do not include sub-modules' parameters any more, to get all the parameters to be\ntrained by optimizer, including sub-modules' during training, you'll need to call the new interface function   .collect_params() . \nTo collect self-defined updates for training, still call  .collect_self_updates() .   MODIFIED :  .get_weights()  and  .set_weights()  traverse the parameters in the same order of sub-modules, so they're  incompatible  with previous version.  MODIFIED : Rewind all  trainable  flags, you're now expected to use the  include  and  exclude  arguments in  .collect_params()  and  .collect_self_updates()  to enable/disable training for certain module's parameters.  MODIFIED : to define self-update expression for  self_updating_variable , use  .update  attribute instead of previous  .default_update  NEW : add auto-naming feature to root class  Module : if a sub-module is unnamed yet, it'll be auto-named by its instance name, \nfrom now on you don't need to name a sub-module manually any more.  NEW : add  .set_weights_by_name()  to  Module  class, you can use this function to set module weights saved by previous version of Dandelion",
            "title": "version 0.14.0 [4-10-2018]"
        }
    ]
}